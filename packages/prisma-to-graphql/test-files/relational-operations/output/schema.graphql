# generated by prisma-to-graphql

type Mutation {
    Users(
        create: User_CreateInput
        update: User_UpdateInput
        upsert: User_UpsertInput
    ): User_QueryOutput!
    UserSettings(
        create: UserSettings_CreateInput
        update: UserSettings_UpdateInput
        upsert: UserSettings_UpsertInput
    ): UserSettings_QueryOutput!
}

type Query {
    Users(
        where: User_WhereInput!
        orderBy: [User_OrderByInput!]
        cursor: User_WhereUnfilteredUniqueInput
        distinct: [User_DistinctInput!]
        take: Int
        skip: Int
    ): User_QueryOutput!
    UserSettings(
        where: UserSettings_WhereInput!
        orderBy: [UserSettings_OrderByInput!]
        cursor: UserSettings_WhereUnfilteredUniqueInput
        distinct: [UserSettings_DistinctInput!]
        take: Int
        skip: Int
    ): UserSettings_QueryOutput!
}

scalar DateTime

enum SortOrder {
    asc
    desc
}

enum NullsOrder {
    first
    last
}

enum User_DistinctInput {
    id
    createdAt
    updatedAt
    email
    password
    firstName
    lastName
    role
    phoneNumber
}

enum UserSettings_DistinctInput {
    id
    createdAt
    updatedAt
}

type _AllModels {
    User: User
    UserSettings: UserSettings
}

type User {
    id: String!
    createdAt: DateTime!
    updatedAt: DateTime!
    email: String!
    password: String!
    firstName: String
    lastName: String
    role: String
    phoneNumber: String
    settings: UserSettings
}

input SortOrderWithNulls {
    sort: SortOrder!
    nulls: NullsOrder
}

type User_QueryOutput {
    # Total count of items based on the provided 'where' argument.
    # This total ignores pagination args so that, when using pagination, you can know how many pages are needed.
    total: Int!
    items: [User!]!
}

input User_WhereInput {
    AND: [User_WhereInput!]
    OR: [User_WhereInput!]
    NOT: [User_WhereInput!]
    id: StringFilterInput
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    email: StringFilterInput
    password: StringFilterInput
    firstName: StringFilterInput
    lastName: StringFilterInput
    role: StringFilterInput
    phoneNumber: StringFilterInput
    settings: UserSettings_WhereInput
}

input User_OrderByInput {
    id: SortOrder
    createdAt: SortOrder
    updatedAt: SortOrder
    email: SortOrder
    password: SortOrder
    firstName: SortOrderWithNulls
    lastName: SortOrderWithNulls
    role: SortOrderWithNulls
    phoneNumber: SortOrderWithNulls
    settings: UserSettings_OrderByInput
}

input User_WhereUnfilteredUniqueInput {
    AND: [User_WhereInput!]
    OR: [User_WhereInput!]
    NOT: [User_WhereInput!]
    id: String
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    email: StringFilterInput
    password: StringFilterInput
    firstName: StringFilterInput
    lastName: StringFilterInput
    role: StringFilterInput
    phoneNumber: StringFilterInput
    settings: UserSettings_WhereInput
}

input StringFilterInput {
    equals: String
    in: [String!]
    notIn: [String!]
    lt: String
    lte: String
    gt: String
    gte: String
    not: StringFilterInput
    contains: String
    startsWith: String
    endsWith: String
}

input DateTimeFilterInput {
    equals: DateTime
    in: [DateTime!]
    notIn: [DateTime!]
    lt: DateTime
    lte: DateTime
    gt: DateTime
    gte: DateTime
    not: DateTimeFilterInput
}

input User_CreateInput {
    data: [User_CreateDataInput!]!
}

input User_UpdateInput {
    data: User_UpdateDataInput!
    where: User_WhereUnfilteredUniqueInput!
}

input User_UpsertInput {
    data: User_UpdateDataInput!
    where: User_WhereRequiredProvidedUniqueInput!
}

input User_WhereRequiredProvidedUniqueInput {
    id: String!
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    email: StringFilterInput
    password: StringFilterInput
    firstName: StringFilterInput
    lastName: StringFilterInput
    role: StringFilterInput
    phoneNumber: StringFilterInput
    settings: UserSettings_WhereInput
}

input User_CreateDataInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
    email: String!
    password: String!
    firstName: String
    lastName: String
    role: String
    phoneNumber: String
    settings: UserSettings_Without_User_ConnectionInput
}

input User_UpdateDataInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
    email: String
    password: String
    firstName: String
    lastName: String
    role: String
    phoneNumber: String
    settings: UserSettings_Without_User_ConnectionInput
}

input User_Without_UserSettings_CreateOrConnectInput {
    connect: User_WhereUnfilteredUniqueInput!
    create: User_Without_UserSettings_CreateInput!
}

input User_Without_UserSettings_CreateInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
    email: String!
    password: String!
    firstName: String
    lastName: String
    role: String
    phoneNumber: String
}

input User_Without_UserSettings_ConnectionInput {
    create: User_Without_UserSettings_CreateInput
    connectOrCreate: User_Without_UserSettings_CreateOrConnectInput
    connect: User_WhereUnfilteredUniqueInput
}

type UserSettings {
    id: String!
    createdAt: DateTime!
    updatedAt: DateTime!
    user: User!
}

type UserSettings_QueryOutput {
    # Total count of items based on the provided 'where' argument.
    # This total ignores pagination args so that, when using pagination, you can know how many pages are needed.
    total: Int!
    items: [UserSettings!]!
}

input UserSettings_WhereInput {
    AND: [UserSettings_WhereInput!]
    OR: [UserSettings_WhereInput!]
    NOT: [UserSettings_WhereInput!]
    id: StringFilterInput
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    user: User_WhereInput
}

input UserSettings_OrderByInput {
    id: SortOrder
    createdAt: SortOrder
    updatedAt: SortOrder
    user: User_OrderByInput
}

input UserSettings_WhereUnfilteredUniqueInput {
    AND: [UserSettings_WhereInput!]
    OR: [UserSettings_WhereInput!]
    NOT: [UserSettings_WhereInput!]
    id: String
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    user: User_WhereInput
}

input UserSettings_CreateInput {
    data: [UserSettings_CreateDataInput!]!
}

input UserSettings_UpdateInput {
    data: UserSettings_UpdateDataInput!
    where: UserSettings_WhereUnfilteredUniqueInput!
}

input UserSettings_UpsertInput {
    data: UserSettings_UpdateDataInput!
    where: UserSettings_WhereRequiredProvidedUniqueInput!
}

input UserSettings_WhereRequiredProvidedUniqueInput {
    id: String!
    createdAt: DateTimeFilterInput
    updatedAt: DateTimeFilterInput
    user: User_WhereInput
}

input UserSettings_CreateDataInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
    user: User_Without_UserSettings_ConnectionInput!
}

input UserSettings_UpdateDataInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
    user: User_Without_UserSettings_ConnectionInput
}

input UserSettings_Without_User_CreateOrConnectInput {
    connect: UserSettings_WhereUnfilteredUniqueInput!
    create: UserSettings_Without_User_CreateInput!
}

input UserSettings_Without_User_CreateInput {
    id: String
    createdAt: DateTime
    updatedAt: DateTime
}

input UserSettings_Without_User_ConnectionInput {
    create: UserSettings_Without_User_CreateInput
    connectOrCreate: UserSettings_Without_User_CreateOrConnectInput
    connect: UserSettings_WhereUnfilteredUniqueInput
}