{
    "testGeneration": {
        "multi-model": "Error: ENOENT: no such file or directory, open '/Users/electrovir/repos/electrovir/prisma-to-graphql/packages/prisma-to-graphql/test-files/multi-model/output/resolvers.ts'",
        "multi-with-operations": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Query_Companies(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'Company', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Companies(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'Company', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\nCompanies: Mutation_Companies,\n},\nQuery: {\nUsers: Query_Users,\nCompanies: Query_Companies,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\nCompanies(\ncreate: Company_CreateInput\nupdate: Company_UpdateInput\nupsert: Company_UpsertInput\n): Company_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\nCompanies(\nwhere: Company_WhereInput!\norderBy: [Company_OrderByInput!]\ncursor: Company_WhereUnfilteredUniqueInput\ndistinct: [Company_DistinctInput!]\ntake: Int\nskip: Int\n): Company_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\npassword\nfirstName\nlastName\nrole\nphoneNumber\n}\nenum Company_DistinctInput {\nid\ncreatedAt\nupdatedAt\nname\n}\ntype _AllModels {\nUser: User\nCompany: Company\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\npassword: String!\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\npassword: SortOrder\nfirstName: SortOrderWithNulls\nlastName: SortOrderWithNulls\nrole: SortOrderWithNulls\nphoneNumber: SortOrderWithNulls\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\npassword: String!\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\npassword: String\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\n}\ntype Company {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nname: String!\n}\ntype Company_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [Company!]!\n}\ninput Company_WhereInput {\nAND: [Company_WhereInput!]\nOR: [Company_WhereInput!]\nNOT: [Company_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nname: StringFilterInput\n}\ninput Company_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nname: SortOrder\n}\ninput Company_WhereUnfilteredUniqueInput {\nAND: [Company_WhereInput!]\nOR: [Company_WhereInput!]\nNOT: [Company_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nname: StringFilterInput\n}\ninput Company_CreateInput {\ndata: [Company_CreateDataInput!]!\n}\ninput Company_UpdateInput {\ndata: Company_UpdateDataInput!\nwhere: Company_WhereUnfilteredUniqueInput!\n}\ninput Company_UpsertInput {\ndata: Company_UpdateDataInput!\nwhere: Company_WhereRequiredProvidedUniqueInput!\n}\ninput Company_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nname: StringFilterInput\n}\ninput Company_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nname: String!\n}\ninput Company_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nname: String\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\nreadonly Companies: Company_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Mutation_CompaniesArgs = {\ncreate?: InputMaybe<Company_CreateInput>;\nupdate?: InputMaybe<Company_UpdateInput>;\nupsert?: InputMaybe<Company_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\nreadonly Companies: Company_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport type Query_CompaniesArgs = {\nwhere: Company_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<Company_OrderByInput>>;\ncursor?: InputMaybe<Company_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<Company_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\npassword = 'password',\nfirstName = 'firstName',\nlastName = 'lastName',\nrole = 'role',\nphoneNumber = 'phoneNumber'\n}\nexport enum Company_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nname = 'name'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\nreadonly Company?: Maybe<Company>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly password: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\nreadonly lastName?: Maybe<Scalars['String']['output']>;\nreadonly role?: Maybe<Scalars['String']['output']>;\nreadonly phoneNumber?: Maybe<Scalars['String']['output']>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly password?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\nreadonly lastName?: InputMaybe<SortOrderWithNulls>;\nreadonly role?: InputMaybe<SortOrderWithNulls>;\nreadonly phoneNumber?: InputMaybe<SortOrderWithNulls>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly password: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\nreadonly lastName?: InputMaybe<Scalars['String']['input']>;\nreadonly role?: InputMaybe<Scalars['String']['input']>;\nreadonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly password?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\nreadonly lastName?: InputMaybe<Scalars['String']['input']>;\nreadonly role?: InputMaybe<Scalars['String']['input']>;\nreadonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\n};\nexport type Company = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly name: Scalars['String']['output'];\n};\nexport type Company_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<Company>;\n};\nexport type Company_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly name?: InputMaybe<StringFilterInput>;\n};\nexport type Company_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly name?: InputMaybe<SortOrder | `${SortOrder}`>;\n};\nexport type Company_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly name?: InputMaybe<StringFilterInput>;\n};\nexport type Company_CreateInput = {\nreadonly data: ReadonlyArray<Company_CreateDataInput>;\n};\nexport type Company_UpdateInput = {\nreadonly data: Company_UpdateDataInput;\nreadonly where: Company_WhereUnfilteredUniqueInput;\n};\nexport type Company_UpsertInput = {\nreadonly data: Company_UpdateDataInput;\nreadonly where: Company_WhereRequiredProvidedUniqueInput;\n};\nexport type Company_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly name?: InputMaybe<StringFilterInput>;\n};\nexport type Company_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly name: Scalars['String']['input'];\n};\nexport type Company_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly name?: InputMaybe<Scalars['String']['input']>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\nCompany_DistinctInput: Company_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nCompany: ResolverTypeWrapper<Company>;\nCompany_QueryOutput: ResolverTypeWrapper<Company_QueryOutput>;\nCompany_WhereInput: Company_WhereInput;\nCompany_OrderByInput: Company_OrderByInput;\nCompany_WhereUnfilteredUniqueInput: Company_WhereUnfilteredUniqueInput;\nCompany_CreateInput: Company_CreateInput;\nCompany_UpdateInput: Company_UpdateInput;\nCompany_UpsertInput: Company_UpsertInput;\nCompany_WhereRequiredProvidedUniqueInput: Company_WhereRequiredProvidedUniqueInput;\nCompany_CreateDataInput: Company_CreateDataInput;\nCompany_UpdateDataInput: Company_UpdateDataInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nCompany: Company;\nCompany_QueryOutput: Company_QueryOutput;\nCompany_WhereInput: Company_WhereInput;\nCompany_OrderByInput: Company_OrderByInput;\nCompany_WhereUnfilteredUniqueInput: Company_WhereUnfilteredUniqueInput;\nCompany_CreateInput: Company_CreateInput;\nCompany_UpdateInput: Company_UpdateInput;\nCompany_UpsertInput: Company_UpsertInput;\nCompany_WhereRequiredProvidedUniqueInput: Company_WhereRequiredProvidedUniqueInput;\nCompany_CreateDataInput: Company_CreateDataInput;\nCompany_UpdateDataInput: Company_UpdateDataInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\nCompanies?: Resolver<ResolversTypes['Company_QueryOutput'], ParentType, ContextType, Partial<Mutation_CompaniesArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\nCompanies?: Resolver<ResolversTypes['Company_QueryOutput'], ParentType, ContextType, RequireFields<Query_CompaniesArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\nCompany?: Resolver<Maybe<ResolversTypes['Company']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\npassword?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nlastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nrole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nphoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type CompanyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Company'] = ResolversParentTypes['Company']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nname?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Company_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['Company_QueryOutput'] = ResolversParentTypes['Company_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['Company']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\nCompany?: CompanyResolvers<ContextType>;\nCompany_QueryOutput?: Company_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"Companies\": {\n\"args\": {\n\"create\": \"Company_CreateInput\",\n\"update\": \"Company_UpdateInput\",\n\"upsert\": \"Company_UpsertInput\"\n},\n\"output\": \"Company_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"Companies\": {\n\"args\": {\n\"where\": \"Company_WhereInput!\",\n\"orderBy\": \"[Company_OrderByInput!]\",\n\"cursor\": \"Company_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[Company_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"Company_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nlastName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nrole: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nphoneNumber: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\nCompany: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nname: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\n} as const;"
        },
        "relational-operations": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Query_UserSettings(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'UserSettings', graphqlArgs, resolveInfo);\n}\nasync function Mutation_UserSettings(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'UserSettings', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\nUserSettings: Mutation_UserSettings,\n},\nQuery: {\nUsers: Query_Users,\nUserSettings: Query_UserSettings,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\nUserSettings(\ncreate: UserSettings_CreateInput\nupdate: UserSettings_UpdateInput\nupsert: UserSettings_UpsertInput\n): UserSettings_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\nUserSettings(\nwhere: UserSettings_WhereInput!\norderBy: [UserSettings_OrderByInput!]\ncursor: UserSettings_WhereUnfilteredUniqueInput\ndistinct: [UserSettings_DistinctInput!]\ntake: Int\nskip: Int\n): UserSettings_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\npassword\nfirstName\nlastName\nrole\nphoneNumber\n}\nenum UserSettings_DistinctInput {\nid\ncreatedAt\nupdatedAt\n}\ntype _AllModels {\nUser: User\nUserSettings: UserSettings\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\npassword: String!\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\nsettings: UserSettings\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\nsettings: UserSettings_WhereInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\npassword: SortOrder\nfirstName: SortOrderWithNulls\nlastName: SortOrderWithNulls\nrole: SortOrderWithNulls\nphoneNumber: SortOrderWithNulls\nsettings: UserSettings_OrderByInput\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\nsettings: UserSettings_WhereInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\nlastName: StringFilterInput\nrole: StringFilterInput\nphoneNumber: StringFilterInput\nsettings: UserSettings_WhereInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\npassword: String!\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\nsettings: UserSettings_Without_User_ConnectionInput\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\npassword: String\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\nsettings: UserSettings_Without_User_ConnectionInput\n}\ninput User_Without_UserSettings_CreateOrConnectInput {\nconnect: [User_WhereUnfilteredUniqueInput]!\ncreate: [User_Without_UserSettings_CreateInput]!\n}\ninput User_Without_UserSettings_CreateInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\npassword: String!\nfirstName: String\nlastName: String\nrole: String\nphoneNumber: String\n}\ninput User_Without_UserSettings_ConnectionManyInput {\ncreate: [User_Without_UserSettings_CreateInput]\nconnectOrCreate: User_Without_UserSettings_CreateOrConnectInput\nconnect: [User_WhereUnfilteredUniqueInput]\n}\ninput User_Without_UserSettings_ConnectionInput {\ncreate: User_Without_UserSettings_CreateInput\nconnectOrCreate: User_Without_UserSettings_CreateOrConnectInput\nconnect: User_WhereUnfilteredUniqueInput\n}\ntype UserSettings {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nuser: User!\n}\ntype UserSettings_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [UserSettings!]!\n}\ninput UserSettings_WhereInput {\nAND: [UserSettings_WhereInput!]\nOR: [UserSettings_WhereInput!]\nNOT: [UserSettings_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput UserSettings_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nuser: User_OrderByInput\n}\ninput UserSettings_WhereUnfilteredUniqueInput {\nAND: [UserSettings_WhereInput!]\nOR: [UserSettings_WhereInput!]\nNOT: [UserSettings_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput UserSettings_CreateInput {\ndata: [UserSettings_CreateDataInput!]!\n}\ninput UserSettings_UpdateInput {\ndata: UserSettings_UpdateDataInput!\nwhere: UserSettings_WhereUnfilteredUniqueInput!\n}\ninput UserSettings_UpsertInput {\ndata: UserSettings_UpdateDataInput!\nwhere: UserSettings_WhereRequiredProvidedUniqueInput!\n}\ninput UserSettings_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput UserSettings_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nuser: User_Without_UserSettings_ConnectionInput!\n}\ninput UserSettings_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nuser: User_Without_UserSettings_ConnectionInput\n}\ninput UserSettings_Without_User_CreateOrConnectInput {\nconnect: [UserSettings_WhereUnfilteredUniqueInput]!\ncreate: [UserSettings_Without_User_CreateInput]!\n}\ninput UserSettings_Without_User_CreateInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\n}\ninput UserSettings_Without_User_ConnectionManyInput {\ncreate: [UserSettings_Without_User_CreateInput]\nconnectOrCreate: UserSettings_Without_User_CreateOrConnectInput\nconnect: [UserSettings_WhereUnfilteredUniqueInput]\n}\ninput UserSettings_Without_User_ConnectionInput {\ncreate: UserSettings_Without_User_CreateInput\nconnectOrCreate: UserSettings_Without_User_CreateOrConnectInput\nconnect: UserSettings_WhereUnfilteredUniqueInput\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\nreadonly UserSettings: UserSettings_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Mutation_UserSettingsArgs = {\ncreate?: InputMaybe<UserSettings_CreateInput>;\nupdate?: InputMaybe<UserSettings_UpdateInput>;\nupsert?: InputMaybe<UserSettings_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\nreadonly UserSettings: UserSettings_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport type Query_UserSettingsArgs = {\nwhere: UserSettings_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<UserSettings_OrderByInput>>;\ncursor?: InputMaybe<UserSettings_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<UserSettings_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\npassword = 'password',\nfirstName = 'firstName',\nlastName = 'lastName',\nrole = 'role',\nphoneNumber = 'phoneNumber'\n}\nexport enum UserSettings_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\nreadonly UserSettings?: Maybe<UserSettings>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly password: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\nreadonly lastName?: Maybe<Scalars['String']['output']>;\nreadonly role?: Maybe<Scalars['String']['output']>;\nreadonly phoneNumber?: Maybe<Scalars['String']['output']>;\nreadonly settings?: Maybe<UserSettings>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\nreadonly settings?: InputMaybe<UserSettings_WhereInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly password?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\nreadonly lastName?: InputMaybe<SortOrderWithNulls>;\nreadonly role?: InputMaybe<SortOrderWithNulls>;\nreadonly phoneNumber?: InputMaybe<SortOrderWithNulls>;\nreadonly settings?: InputMaybe<UserSettings_OrderByInput>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\nreadonly settings?: InputMaybe<UserSettings_WhereInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\nreadonly lastName?: InputMaybe<StringFilterInput>;\nreadonly role?: InputMaybe<StringFilterInput>;\nreadonly phoneNumber?: InputMaybe<StringFilterInput>;\nreadonly settings?: InputMaybe<UserSettings_WhereInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly password: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\nreadonly lastName?: InputMaybe<Scalars['String']['input']>;\nreadonly role?: InputMaybe<Scalars['String']['input']>;\nreadonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\nreadonly settings?: InputMaybe<UserSettings_Without_User_ConnectionInput>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly password?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\nreadonly lastName?: InputMaybe<Scalars['String']['input']>;\nreadonly role?: InputMaybe<Scalars['String']['input']>;\nreadonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\nreadonly settings?: InputMaybe<UserSettings_Without_User_ConnectionInput>;\n};\nexport type User_Without_UserSettings_CreateOrConnectInput = {\nreadonly connect: ReadonlyArray<InputMaybe<User_WhereUnfilteredUniqueInput>>;\nreadonly create: ReadonlyArray<InputMaybe<User_Without_UserSettings_CreateInput>>;\n};\nexport type User_Without_UserSettings_CreateInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly password: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\nreadonly lastName?: InputMaybe<Scalars['String']['input']>;\nreadonly role?: InputMaybe<Scalars['String']['input']>;\nreadonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_Without_UserSettings_ConnectionManyInput = {\nreadonly create?: InputMaybe<ReadonlyArray<InputMaybe<User_Without_UserSettings_CreateInput>>>;\nreadonly connectOrCreate?: InputMaybe<User_Without_UserSettings_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<ReadonlyArray<InputMaybe<User_WhereUnfilteredUniqueInput>>>;\n};\nexport type User_Without_UserSettings_ConnectionInput = {\nreadonly create?: InputMaybe<User_Without_UserSettings_CreateInput>;\nreadonly connectOrCreate?: InputMaybe<User_Without_UserSettings_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<User_WhereUnfilteredUniqueInput>;\n};\nexport type UserSettings = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly user: User;\n};\nexport type UserSettings_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<UserSettings>;\n};\nexport type UserSettings_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type UserSettings_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly user?: InputMaybe<User_OrderByInput>;\n};\nexport type UserSettings_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type UserSettings_CreateInput = {\nreadonly data: ReadonlyArray<UserSettings_CreateDataInput>;\n};\nexport type UserSettings_UpdateInput = {\nreadonly data: UserSettings_UpdateDataInput;\nreadonly where: UserSettings_WhereUnfilteredUniqueInput;\n};\nexport type UserSettings_UpsertInput = {\nreadonly data: UserSettings_UpdateDataInput;\nreadonly where: UserSettings_WhereRequiredProvidedUniqueInput;\n};\nexport type UserSettings_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type UserSettings_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly user: User_Without_UserSettings_ConnectionInput;\n};\nexport type UserSettings_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly user?: InputMaybe<User_Without_UserSettings_ConnectionInput>;\n};\nexport type UserSettings_Without_User_CreateOrConnectInput = {\nreadonly connect: ReadonlyArray<InputMaybe<UserSettings_WhereUnfilteredUniqueInput>>;\nreadonly create: ReadonlyArray<InputMaybe<UserSettings_Without_User_CreateInput>>;\n};\nexport type UserSettings_Without_User_CreateInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\n};\nexport type UserSettings_Without_User_ConnectionManyInput = {\nreadonly create?: InputMaybe<ReadonlyArray<InputMaybe<UserSettings_Without_User_CreateInput>>>;\nreadonly connectOrCreate?: InputMaybe<UserSettings_Without_User_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<ReadonlyArray<InputMaybe<UserSettings_WhereUnfilteredUniqueInput>>>;\n};\nexport type UserSettings_Without_User_ConnectionInput = {\nreadonly create?: InputMaybe<UserSettings_Without_User_CreateInput>;\nreadonly connectOrCreate?: InputMaybe<UserSettings_Without_User_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<UserSettings_WhereUnfilteredUniqueInput>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\nUserSettings_DistinctInput: UserSettings_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nUser_Without_UserSettings_CreateOrConnectInput: User_Without_UserSettings_CreateOrConnectInput;\nUser_Without_UserSettings_CreateInput: User_Without_UserSettings_CreateInput;\nUser_Without_UserSettings_ConnectionManyInput: User_Without_UserSettings_ConnectionManyInput;\nUser_Without_UserSettings_ConnectionInput: User_Without_UserSettings_ConnectionInput;\nUserSettings: ResolverTypeWrapper<UserSettings>;\nUserSettings_QueryOutput: ResolverTypeWrapper<UserSettings_QueryOutput>;\nUserSettings_WhereInput: UserSettings_WhereInput;\nUserSettings_OrderByInput: UserSettings_OrderByInput;\nUserSettings_WhereUnfilteredUniqueInput: UserSettings_WhereUnfilteredUniqueInput;\nUserSettings_CreateInput: UserSettings_CreateInput;\nUserSettings_UpdateInput: UserSettings_UpdateInput;\nUserSettings_UpsertInput: UserSettings_UpsertInput;\nUserSettings_WhereRequiredProvidedUniqueInput: UserSettings_WhereRequiredProvidedUniqueInput;\nUserSettings_CreateDataInput: UserSettings_CreateDataInput;\nUserSettings_UpdateDataInput: UserSettings_UpdateDataInput;\nUserSettings_Without_User_CreateOrConnectInput: UserSettings_Without_User_CreateOrConnectInput;\nUserSettings_Without_User_CreateInput: UserSettings_Without_User_CreateInput;\nUserSettings_Without_User_ConnectionManyInput: UserSettings_Without_User_ConnectionManyInput;\nUserSettings_Without_User_ConnectionInput: UserSettings_Without_User_ConnectionInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nUser_Without_UserSettings_CreateOrConnectInput: User_Without_UserSettings_CreateOrConnectInput;\nUser_Without_UserSettings_CreateInput: User_Without_UserSettings_CreateInput;\nUser_Without_UserSettings_ConnectionManyInput: User_Without_UserSettings_ConnectionManyInput;\nUser_Without_UserSettings_ConnectionInput: User_Without_UserSettings_ConnectionInput;\nUserSettings: UserSettings;\nUserSettings_QueryOutput: UserSettings_QueryOutput;\nUserSettings_WhereInput: UserSettings_WhereInput;\nUserSettings_OrderByInput: UserSettings_OrderByInput;\nUserSettings_WhereUnfilteredUniqueInput: UserSettings_WhereUnfilteredUniqueInput;\nUserSettings_CreateInput: UserSettings_CreateInput;\nUserSettings_UpdateInput: UserSettings_UpdateInput;\nUserSettings_UpsertInput: UserSettings_UpsertInput;\nUserSettings_WhereRequiredProvidedUniqueInput: UserSettings_WhereRequiredProvidedUniqueInput;\nUserSettings_CreateDataInput: UserSettings_CreateDataInput;\nUserSettings_UpdateDataInput: UserSettings_UpdateDataInput;\nUserSettings_Without_User_CreateOrConnectInput: UserSettings_Without_User_CreateOrConnectInput;\nUserSettings_Without_User_CreateInput: UserSettings_Without_User_CreateInput;\nUserSettings_Without_User_ConnectionManyInput: UserSettings_Without_User_ConnectionManyInput;\nUserSettings_Without_User_ConnectionInput: UserSettings_Without_User_ConnectionInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\nUserSettings?: Resolver<ResolversTypes['UserSettings_QueryOutput'], ParentType, ContextType, Partial<Mutation_UserSettingsArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\nUserSettings?: Resolver<ResolversTypes['UserSettings_QueryOutput'], ParentType, ContextType, RequireFields<Query_UserSettingsArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\nUserSettings?: Resolver<Maybe<ResolversTypes['UserSettings']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\npassword?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nlastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nrole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nphoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\nsettings?: Resolver<Maybe<ResolversTypes['UserSettings']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettings'] = ResolversParentTypes['UserSettings']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nuser?: Resolver<ResolversTypes['User'], ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserSettings_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserSettings_QueryOutput'] = ResolversParentTypes['UserSettings_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['UserSettings']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\nUserSettings?: UserSettingsResolvers<ContextType>;\nUserSettings_QueryOutput?: UserSettings_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"UserSettings\": {\n\"args\": {\n\"create\": \"UserSettings_CreateInput\",\n\"update\": \"UserSettings_UpdateInput\",\n\"upsert\": \"UserSettings_UpsertInput\"\n},\n\"output\": \"UserSettings_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"UserSettings\": {\n\"args\": {\n\"where\": \"UserSettings_WhereInput!\",\n\"orderBy\": \"[UserSettings_OrderByInput!]\",\n\"cursor\": \"UserSettings_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[UserSettings_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"UserSettings_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nlastName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nrole: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nphoneNumber: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nsettings: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'UserSettings',\nrelationFromFields: [],\nrelationToFields: [],\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: true,\n},\n},\nUserSettings: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nuser: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'User',\nrelationFromFields: [\n'userId',\n],\nrelationToFields: [\n'id',\n],\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: true,\n},\n},\n} as const;"
        },
        "single-model": "Error: ENOENT: no such file or directory, open '/Users/electrovir/repos/electrovir/prisma-to-graphql/packages/prisma-to-graphql/test-files/single-model/output/resolvers.ts'",
        "omits-fields": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\n},\nQuery: {\nUsers: Query_Users,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\nfirstName\n}\ntype _AllModels {\nUser: User\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\nfirstName: String\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\nfirstName: SortOrderWithNulls\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\nfirstName: String\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\nfirstName: String\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\nfirstName = 'firstName'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\n} as const;"
        },
        "omits-models": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\n},\nQuery: {\nUsers: Query_Users,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\nfirstName\n}\ntype _AllModels {\nUser: User\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\nfirstName: String\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\nfirstName: SortOrderWithNulls\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\nfirstName: String\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\nfirstName: String\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\nfirstName = 'firstName'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\n} as const;"
        },
        "omits-output-fields": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\n},\nQuery: {\nUsers: Query_Users,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\npassword\nfirstName\n}\ntype _AllModels {\nUser: User\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\nfirstName: String\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\npassword: SortOrder\nfirstName: SortOrderWithNulls\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\npassword: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\npassword: String!\nfirstName: String\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\npassword: String\nfirstName: String\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\npassword = 'password',\nfirstName = 'firstName'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly password?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly password?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly password: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly password?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\n} as const;"
        },
        "omits-input-fields": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\n},\nQuery: {\nUsers: Query_Users,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\nemail\nfirstName\n}\ntype _AllModels {\nUser: User\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nemail: String!\npassword: String!\nfirstName: String\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nemail: SortOrder\nfirstName: SortOrderWithNulls\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nemail: StringFilterInput\nfirstName: StringFilterInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String!\nfirstName: String\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nemail: String\nfirstName: String\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt',\nemail = 'email',\nfirstName = 'firstName'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly email: Scalars['String']['output'];\nreadonly password: Scalars['String']['output'];\nreadonly firstName?: Maybe<Scalars['String']['output']>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly email?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly firstName?: InputMaybe<SortOrderWithNulls>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly email?: InputMaybe<StringFilterInput>;\nreadonly firstName?: InputMaybe<StringFilterInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email: Scalars['String']['input'];\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly email?: InputMaybe<Scalars['String']['input']>;\nreadonly firstName?: InputMaybe<Scalars['String']['input']>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nemail?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\npassword?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\nfirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nemail: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\npassword: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nfirstName: {\nisList: false,\nisRequired: false,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\n},\n} as const;"
        },
        "includes-a-list-field": {
            "resolversTs": "// generated by prisma-to-graphql\nimport {GraphQLResolveInfo} from 'graphql';\nimport {runPrismaResolver} from '@prisma-to-graphql/prisma-resolver';\nasync function Query_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Users(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'User', graphqlArgs, resolveInfo);\n}\nasync function Query_Posts(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'Post', graphqlArgs, resolveInfo);\n}\nasync function Mutation_Posts(parentValue: unknown, graphqlArgs: unknown, context: {prismaClient: unknown}, resolveInfo: GraphQLResolveInfo) {\nreturn await runPrismaResolver(context.prismaClient, 'Post', graphqlArgs, resolveInfo);\n}\nexport const resolvers = {\nMutation: {\nUsers: Mutation_Users,\nPosts: Mutation_Posts,\n},\nQuery: {\nUsers: Query_Users,\nPosts: Query_Posts,\n},\n};",
            "schema": "# generated by prisma-to-graphql\ntype Mutation {\nUsers(\ncreate: User_CreateInput\nupdate: User_UpdateInput\nupsert: User_UpsertInput\n): User_QueryOutput!\nPosts(\ncreate: Post_CreateInput\nupdate: Post_UpdateInput\nupsert: Post_UpsertInput\n): Post_QueryOutput!\n}\ntype Query {\nUsers(\nwhere: User_WhereInput!\norderBy: [User_OrderByInput!]\ncursor: User_WhereUnfilteredUniqueInput\ndistinct: [User_DistinctInput!]\ntake: Int\nskip: Int\n): User_QueryOutput!\nPosts(\nwhere: Post_WhereInput!\norderBy: [Post_OrderByInput!]\ncursor: Post_WhereUnfilteredUniqueInput\ndistinct: [Post_DistinctInput!]\ntake: Int\nskip: Int\n): Post_QueryOutput!\n}\nscalar DateTime\nenum SortOrder {\nasc\ndesc\n}\nenum NullsOrder {\nfirst\nlast\n}\nenum User_DistinctInput {\nid\ncreatedAt\nupdatedAt\n}\nenum Post_DistinctInput {\nid\ncreatedAt\nupdatedAt\n}\ntype _AllModels {\nUser: User\nPost: Post\n}\ntype User {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nposts: [Post]!\n}\ninput SortOrderWithNulls {\nsort: SortOrder!\nnulls: NullsOrder\n}\ntype User_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [User!]!\n}\ninput User_WhereInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nposts: Post_WhereInput\n}\ninput User_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nposts: Post_OrderByInput\n}\ninput User_WhereUnfilteredUniqueInput {\nAND: [User_WhereInput!]\nOR: [User_WhereInput!]\nNOT: [User_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nposts: Post_WhereInput\n}\ninput StringFilterInput {\nequals: String\nin: [String!]\nnotIn: [String!]\nlt: String\nlte: String\ngt: String\ngte: String\nnot: StringFilterInput\ncontains: String\nstartsWith: String\nendsWith: String\n}\ninput DateTimeFilterInput {\nequals: DateTime\nin: [DateTime!]\nnotIn: [DateTime!]\nlt: DateTime\nlte: DateTime\ngt: DateTime\ngte: DateTime\nnot: DateTimeFilterInput\n}\ninput User_CreateInput {\ndata: [User_CreateDataInput!]!\n}\ninput User_UpdateInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereUnfilteredUniqueInput!\n}\ninput User_UpsertInput {\ndata: User_UpdateDataInput!\nwhere: User_WhereRequiredProvidedUniqueInput!\n}\ninput User_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nposts: Post_WhereInput\n}\ninput User_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nposts: Post_Without_User_ConnectionManyInput\n}\ninput User_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nposts: Post_Without_User_ConnectionInput\n}\ninput User_Without_Post_CreateOrConnectInput {\nconnect: [User_WhereUnfilteredUniqueInput]!\ncreate: [User_Without_Post_CreateInput]!\n}\ninput User_Without_Post_CreateInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\n}\ninput User_Without_Post_ConnectionManyInput {\ncreate: [User_Without_Post_CreateInput]\nconnectOrCreate: User_Without_Post_CreateOrConnectInput\nconnect: [User_WhereUnfilteredUniqueInput]\n}\ninput User_Without_Post_ConnectionInput {\ncreate: User_Without_Post_CreateInput\nconnectOrCreate: User_Without_Post_CreateOrConnectInput\nconnect: User_WhereUnfilteredUniqueInput\n}\ntype Post {\nid: String!\ncreatedAt: DateTime!\nupdatedAt: DateTime!\nuser: User!\n}\ntype Post_QueryOutput {\n# Total count of items based on the provided 'where' argument.\n# This total ignores pagination args so that, when using pagination, you can know how many pages are needed.\ntotal: Int!\nitems: [Post!]!\n}\ninput Post_WhereInput {\nAND: [Post_WhereInput!]\nOR: [Post_WhereInput!]\nNOT: [Post_WhereInput!]\nid: StringFilterInput\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput Post_OrderByInput {\nid: SortOrder\ncreatedAt: SortOrder\nupdatedAt: SortOrder\nuser: User_OrderByInput\n}\ninput Post_WhereUnfilteredUniqueInput {\nAND: [Post_WhereInput!]\nOR: [Post_WhereInput!]\nNOT: [Post_WhereInput!]\nid: String\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput Post_CreateInput {\ndata: [Post_CreateDataInput!]!\n}\ninput Post_UpdateInput {\ndata: Post_UpdateDataInput!\nwhere: Post_WhereUnfilteredUniqueInput!\n}\ninput Post_UpsertInput {\ndata: Post_UpdateDataInput!\nwhere: Post_WhereRequiredProvidedUniqueInput!\n}\ninput Post_WhereRequiredProvidedUniqueInput {\nid: String!\ncreatedAt: DateTimeFilterInput\nupdatedAt: DateTimeFilterInput\nuser: User_WhereInput\n}\ninput Post_CreateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nuser: User_Without_Post_ConnectionInput!\n}\ninput Post_UpdateDataInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\nuser: User_Without_Post_ConnectionInput\n}\ninput Post_Without_User_CreateOrConnectInput {\nconnect: [Post_WhereUnfilteredUniqueInput]!\ncreate: [Post_Without_User_CreateInput]!\n}\ninput Post_Without_User_CreateInput {\nid: String\ncreatedAt: DateTime\nupdatedAt: DateTime\n}\ninput Post_Without_User_ConnectionManyInput {\ncreate: [Post_Without_User_CreateInput]\nconnectOrCreate: Post_Without_User_CreateOrConnectInput\nconnect: [Post_WhereUnfilteredUniqueInput]\n}\ninput Post_Without_User_ConnectionInput {\ncreate: Post_Without_User_CreateInput\nconnectOrCreate: Post_Without_User_CreateOrConnectInput\nconnect: Post_WhereUnfilteredUniqueInput\n}",
            "schemaTs": "// generated by prisma-to-graphql\nimport type { UtcIsoString } from 'date-vir';\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nexport type Maybe<T> = T | null | undefined;\nexport type InputMaybe<T> = T | null | undefined;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\nID: { input: string; output: string; }\nString: { input: string; output: string; }\nBoolean: { input: boolean; output: boolean; }\nInt: { input: number; output: number; }\nFloat: { input: number; output: number; }\nDateTime: { input: string | Date; output: UtcIsoString; }\n};\nexport type Mutation = {\nreadonly Users: User_QueryOutput;\nreadonly Posts: Post_QueryOutput;\n};\nexport type Mutation_UsersArgs = {\ncreate?: InputMaybe<User_CreateInput>;\nupdate?: InputMaybe<User_UpdateInput>;\nupsert?: InputMaybe<User_UpsertInput>;\n};\nexport type Mutation_PostsArgs = {\ncreate?: InputMaybe<Post_CreateInput>;\nupdate?: InputMaybe<Post_UpdateInput>;\nupsert?: InputMaybe<Post_UpsertInput>;\n};\nexport type Query = {\nreadonly Users: User_QueryOutput;\nreadonly Posts: Post_QueryOutput;\n};\nexport type Query_UsersArgs = {\nwhere: User_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\ncursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport type Query_PostsArgs = {\nwhere: Post_WhereInput;\norderBy?: InputMaybe<ReadonlyArray<Post_OrderByInput>>;\ncursor?: InputMaybe<Post_WhereUnfilteredUniqueInput>;\ndistinct?: InputMaybe<ReadonlyArray<Post_DistinctInput>>;\ntake?: InputMaybe<Scalars['Int']['input']>;\nskip?: InputMaybe<Scalars['Int']['input']>;\n};\nexport enum SortOrder {\nasc = 'asc',\ndesc = 'desc'\n}\nexport enum NullsOrder {\nfirst = 'first',\nlast = 'last'\n}\nexport enum User_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt'\n}\nexport enum Post_DistinctInput {\nid = 'id',\ncreatedAt = 'createdAt',\nupdatedAt = 'updatedAt'\n}\nexport type _AllModels = {\nreadonly User?: Maybe<User>;\nreadonly Post?: Maybe<Post>;\n};\nexport type User = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly posts: ReadonlyArray<Maybe<Post>>;\n};\nexport type SortOrderWithNulls = {\nreadonly sort: SortOrder | `${SortOrder}`;\nreadonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;\n};\nexport type User_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<User>;\n};\nexport type User_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly posts?: InputMaybe<Post_WhereInput>;\n};\nexport type User_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly posts?: InputMaybe<Post_OrderByInput>;\n};\nexport type User_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly posts?: InputMaybe<Post_WhereInput>;\n};\nexport type StringFilterInput = {\nreadonly equals?: InputMaybe<Scalars['String']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\nreadonly lt?: InputMaybe<Scalars['String']['input']>;\nreadonly lte?: InputMaybe<Scalars['String']['input']>;\nreadonly gt?: InputMaybe<Scalars['String']['input']>;\nreadonly gte?: InputMaybe<Scalars['String']['input']>;\nreadonly not?: InputMaybe<StringFilterInput>;\nreadonly contains?: InputMaybe<Scalars['String']['input']>;\nreadonly startsWith?: InputMaybe<Scalars['String']['input']>;\nreadonly endsWith?: InputMaybe<Scalars['String']['input']>;\n};\nexport type DateTimeFilterInput = {\nreadonly equals?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\nreadonly lt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly lte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly gte?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly not?: InputMaybe<DateTimeFilterInput>;\n};\nexport type User_CreateInput = {\nreadonly data: ReadonlyArray<User_CreateDataInput>;\n};\nexport type User_UpdateInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereUnfilteredUniqueInput;\n};\nexport type User_UpsertInput = {\nreadonly data: User_UpdateDataInput;\nreadonly where: User_WhereRequiredProvidedUniqueInput;\n};\nexport type User_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly posts?: InputMaybe<Post_WhereInput>;\n};\nexport type User_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly posts?: InputMaybe<Post_Without_User_ConnectionManyInput>;\n};\nexport type User_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly posts?: InputMaybe<Post_Without_User_ConnectionInput>;\n};\nexport type User_Without_Post_CreateOrConnectInput = {\nreadonly connect: ReadonlyArray<InputMaybe<User_WhereUnfilteredUniqueInput>>;\nreadonly create: ReadonlyArray<InputMaybe<User_Without_Post_CreateInput>>;\n};\nexport type User_Without_Post_CreateInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\n};\nexport type User_Without_Post_ConnectionManyInput = {\nreadonly create?: InputMaybe<ReadonlyArray<InputMaybe<User_Without_Post_CreateInput>>>;\nreadonly connectOrCreate?: InputMaybe<User_Without_Post_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<ReadonlyArray<InputMaybe<User_WhereUnfilteredUniqueInput>>>;\n};\nexport type User_Without_Post_ConnectionInput = {\nreadonly create?: InputMaybe<User_Without_Post_CreateInput>;\nreadonly connectOrCreate?: InputMaybe<User_Without_Post_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<User_WhereUnfilteredUniqueInput>;\n};\nexport type Post = {\nreadonly id: Scalars['String']['output'];\nreadonly createdAt: Scalars['DateTime']['output'];\nreadonly updatedAt: Scalars['DateTime']['output'];\nreadonly user: User;\n};\nexport type Post_QueryOutput = {\nreadonly total: Scalars['Int']['output'];\nreadonly items: ReadonlyArray<Post>;\n};\nexport type Post_WhereInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly id?: InputMaybe<StringFilterInput>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type Post_OrderByInput = {\nreadonly id?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;\nreadonly user?: InputMaybe<User_OrderByInput>;\n};\nexport type Post_WhereUnfilteredUniqueInput = {\nreadonly AND?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly OR?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly NOT?: InputMaybe<ReadonlyArray<Post_WhereInput>>;\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type Post_CreateInput = {\nreadonly data: ReadonlyArray<Post_CreateDataInput>;\n};\nexport type Post_UpdateInput = {\nreadonly data: Post_UpdateDataInput;\nreadonly where: Post_WhereUnfilteredUniqueInput;\n};\nexport type Post_UpsertInput = {\nreadonly data: Post_UpdateDataInput;\nreadonly where: Post_WhereRequiredProvidedUniqueInput;\n};\nexport type Post_WhereRequiredProvidedUniqueInput = {\nreadonly id: Scalars['String']['input'];\nreadonly createdAt?: InputMaybe<DateTimeFilterInput>;\nreadonly updatedAt?: InputMaybe<DateTimeFilterInput>;\nreadonly user?: InputMaybe<User_WhereInput>;\n};\nexport type Post_CreateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly user: User_Without_Post_ConnectionInput;\n};\nexport type Post_UpdateDataInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly user?: InputMaybe<User_Without_Post_ConnectionInput>;\n};\nexport type Post_Without_User_CreateOrConnectInput = {\nreadonly connect: ReadonlyArray<InputMaybe<Post_WhereUnfilteredUniqueInput>>;\nreadonly create: ReadonlyArray<InputMaybe<Post_Without_User_CreateInput>>;\n};\nexport type Post_Without_User_CreateInput = {\nreadonly id?: InputMaybe<Scalars['String']['input']>;\nreadonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\nreadonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\n};\nexport type Post_Without_User_ConnectionManyInput = {\nreadonly create?: InputMaybe<ReadonlyArray<InputMaybe<Post_Without_User_CreateInput>>>;\nreadonly connectOrCreate?: InputMaybe<Post_Without_User_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<ReadonlyArray<InputMaybe<Post_WhereUnfilteredUniqueInput>>>;\n};\nexport type Post_Without_User_ConnectionInput = {\nreadonly create?: InputMaybe<Post_Without_User_CreateInput>;\nreadonly connectOrCreate?: InputMaybe<Post_Without_User_CreateOrConnectInput>;\nreadonly connect?: InputMaybe<Post_WhereUnfilteredUniqueInput>;\n};\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\nresolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\nresolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\nsubscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\nresolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n| SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n| SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n| ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n| SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\nparent: TParent,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\nexport type NextResolverFn<T> = () => Promise<T>;\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\nnext: NextResolverFn<TResult>,\nparent: TParent,\nargs: TArgs,\ncontext: TContext,\ninfo: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = {\nMutation: ResolverTypeWrapper<{}>;\nQuery: ResolverTypeWrapper<{}>;\nInt: ResolverTypeWrapper<Scalars['Int']['output']>;\nDateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\nSortOrder: SortOrder;\nNullsOrder: NullsOrder;\nUser_DistinctInput: User_DistinctInput;\nPost_DistinctInput: Post_DistinctInput;\n_AllModels: ResolverTypeWrapper<_AllModels>;\nUser: ResolverTypeWrapper<User>;\nString: ResolverTypeWrapper<Scalars['String']['output']>;\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nUser_Without_Post_CreateOrConnectInput: User_Without_Post_CreateOrConnectInput;\nUser_Without_Post_CreateInput: User_Without_Post_CreateInput;\nUser_Without_Post_ConnectionManyInput: User_Without_Post_ConnectionManyInput;\nUser_Without_Post_ConnectionInput: User_Without_Post_ConnectionInput;\nPost: ResolverTypeWrapper<Post>;\nPost_QueryOutput: ResolverTypeWrapper<Post_QueryOutput>;\nPost_WhereInput: Post_WhereInput;\nPost_OrderByInput: Post_OrderByInput;\nPost_WhereUnfilteredUniqueInput: Post_WhereUnfilteredUniqueInput;\nPost_CreateInput: Post_CreateInput;\nPost_UpdateInput: Post_UpdateInput;\nPost_UpsertInput: Post_UpsertInput;\nPost_WhereRequiredProvidedUniqueInput: Post_WhereRequiredProvidedUniqueInput;\nPost_CreateDataInput: Post_CreateDataInput;\nPost_UpdateDataInput: Post_UpdateDataInput;\nPost_Without_User_CreateOrConnectInput: Post_Without_User_CreateOrConnectInput;\nPost_Without_User_CreateInput: Post_Without_User_CreateInput;\nPost_Without_User_ConnectionManyInput: Post_Without_User_ConnectionManyInput;\nPost_Without_User_ConnectionInput: Post_Without_User_ConnectionInput;\nBoolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\n};\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\nMutation: {};\nQuery: {};\nInt: Scalars['Int']['output'];\nDateTime: Scalars['DateTime']['output'];\n_AllModels: _AllModels;\nUser: User;\nString: Scalars['String']['output'];\nSortOrderWithNulls: SortOrderWithNulls;\nUser_QueryOutput: User_QueryOutput;\nUser_WhereInput: User_WhereInput;\nUser_OrderByInput: User_OrderByInput;\nUser_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\nStringFilterInput: StringFilterInput;\nDateTimeFilterInput: DateTimeFilterInput;\nUser_CreateInput: User_CreateInput;\nUser_UpdateInput: User_UpdateInput;\nUser_UpsertInput: User_UpsertInput;\nUser_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\nUser_CreateDataInput: User_CreateDataInput;\nUser_UpdateDataInput: User_UpdateDataInput;\nUser_Without_Post_CreateOrConnectInput: User_Without_Post_CreateOrConnectInput;\nUser_Without_Post_CreateInput: User_Without_Post_CreateInput;\nUser_Without_Post_ConnectionManyInput: User_Without_Post_ConnectionManyInput;\nUser_Without_Post_ConnectionInput: User_Without_Post_ConnectionInput;\nPost: Post;\nPost_QueryOutput: Post_QueryOutput;\nPost_WhereInput: Post_WhereInput;\nPost_OrderByInput: Post_OrderByInput;\nPost_WhereUnfilteredUniqueInput: Post_WhereUnfilteredUniqueInput;\nPost_CreateInput: Post_CreateInput;\nPost_UpdateInput: Post_UpdateInput;\nPost_UpsertInput: Post_UpsertInput;\nPost_WhereRequiredProvidedUniqueInput: Post_WhereRequiredProvidedUniqueInput;\nPost_CreateDataInput: Post_CreateDataInput;\nPost_UpdateDataInput: Post_UpdateDataInput;\nPost_Without_User_CreateOrConnectInput: Post_Without_User_CreateOrConnectInput;\nPost_Without_User_CreateInput: Post_Without_User_CreateInput;\nPost_Without_User_ConnectionManyInput: Post_Without_User_ConnectionManyInput;\nPost_Without_User_ConnectionInput: Post_Without_User_ConnectionInput;\nBoolean: Scalars['Boolean']['output'];\n};\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\nPosts?: Resolver<ResolversTypes['Post_QueryOutput'], ParentType, ContextType, Partial<Mutation_PostsArgs>>;\n};\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\nUsers?: Resolver<ResolversTypes['User_QueryOutput'], ParentType, ContextType, RequireFields<Query_UsersArgs, 'where'>>;\nPosts?: Resolver<ResolversTypes['Post_QueryOutput'], ParentType, ContextType, RequireFields<Query_PostsArgs, 'where'>>;\n};\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\nname: 'DateTime';\n}\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\nUser?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\nPost?: Resolver<Maybe<ResolversTypes['Post']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nposts?: Resolver<ReadonlyArray<Maybe<ResolversTypes['Post']>>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type User_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type PostResolvers<ContextType = any, ParentType extends ResolversParentTypes['Post'] = ResolversParentTypes['Post']> = {\nid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\ncreatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nupdatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\nuser?: Resolver<ResolversTypes['User'], ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Post_QueryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['Post_QueryOutput'] = ResolversParentTypes['Post_QueryOutput']> = {\ntotal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\nitems?: Resolver<ReadonlyArray<ResolversTypes['Post']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\nexport type Resolvers<ContextType = any> = {\nMutation?: MutationResolvers<ContextType>;\nQuery?: QueryResolvers<ContextType>;\nDateTime?: GraphQLScalarType;\n_AllModels?: _AllModelsResolvers<ContextType>;\nUser?: UserResolvers<ContextType>;\nUser_QueryOutput?: User_QueryOutputResolvers<ContextType>;\nPost?: PostResolvers<ContextType>;\nPost_QueryOutput?: Post_QueryOutputResolvers<ContextType>;\n};\nimport type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';\nexport const operationParams: Readonly<SchemaOperationParams> = {\n\"Mutation\": {\n\"Users\": {\n\"args\": {\n\"create\": \"User_CreateInput\",\n\"update\": \"User_UpdateInput\",\n\"upsert\": \"User_UpsertInput\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"Posts\": {\n\"args\": {\n\"create\": \"Post_CreateInput\",\n\"update\": \"Post_UpdateInput\",\n\"upsert\": \"Post_UpsertInput\"\n},\n\"output\": \"Post_QueryOutput!\"\n}\n},\n\"Query\": {\n\"Users\": {\n\"args\": {\n\"where\": \"User_WhereInput!\",\n\"orderBy\": \"[User_OrderByInput!]\",\n\"cursor\": \"User_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[User_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"User_QueryOutput!\"\n},\n\"Posts\": {\n\"args\": {\n\"where\": \"Post_WhereInput!\",\n\"orderBy\": \"[Post_OrderByInput!]\",\n\"cursor\": \"Post_WhereUnfilteredUniqueInput\",\n\"distinct\": \"[Post_DistinctInput!]\",\n\"take\": \"Int\",\n\"skip\": \"Int\"\n},\n\"output\": \"Post_QueryOutput!\"\n}\n}\n};",
            "modelsTs": "export const models = {\nUser: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nposts: {\nisList: true,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'Post',\nrelationFromFields: [],\nrelationToFields: [],\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: true,\n},\n},\nPost: {\nid: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: true,\nhasDefaultValue: true,\ntype: 'String',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\ncreatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: true,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: false,\n},\nupdatedAt: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'DateTime',\nisGenerated: false,\nisUpdatedAt: true,\nisRelation: false,\n},\nuser: {\nisList: false,\nisRequired: true,\nisUnique: false,\nisId: false,\nhasDefaultValue: false,\ntype: 'User',\nrelationFromFields: [\n'userId',\n],\nrelationToFields: [\n'id',\n],\nisGenerated: false,\nisUpdatedAt: false,\nisRelation: true,\n},\n},\n} as const;"
        }
    }
}
