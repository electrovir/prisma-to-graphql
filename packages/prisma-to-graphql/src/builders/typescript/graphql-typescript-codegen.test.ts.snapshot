exports[`buildSchemaTs > multi-model 1`] = `
"// generated by prisma-to-graphql\\n\\nimport type { UtcIsoString } from 'date-vir';\\nimport type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\\nexport type Maybe<T> = T | null | undefined;\\nexport type InputMaybe<T> = T | null | undefined;\\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\\n/** All built-in and custom scalars, mapped to their actual values */\\nexport type Scalars = {\\n  ID: { input: string; output: string; }\\n  String: { input: string; output: string; }\\n  Boolean: { input: boolean; output: boolean; }\\n  Int: { input: number; output: number; }\\n  Float: { input: number; output: number; }\\n  DateTime: { input: string | Date; output: UtcIsoString; }\\n};\\n\\nexport type Mutation = {\\n  readonly Users: User_Output;\\n  readonly Companies: Company_Output;\\n};\\n\\n\\nexport type Mutation_UsersArgs = {\\n  create?: InputMaybe<User_CreateInput>;\\n  update?: InputMaybe<User_UpdateInput>;\\n  upsert?: InputMaybe<User_UpsertInput>;\\n  delete?: InputMaybe<User_DeleteInput>;\\n};\\n\\n\\nexport type Mutation_CompaniesArgs = {\\n  create?: InputMaybe<Company_CreateInput>;\\n  update?: InputMaybe<Company_UpdateInput>;\\n  upsert?: InputMaybe<Company_UpsertInput>;\\n  delete?: InputMaybe<Company_DeleteInput>;\\n};\\n\\nexport type Query = {\\n  readonly Users: User_Output;\\n  readonly Companies: Company_Output;\\n};\\n\\n\\nexport type Query_UsersArgs = {\\n  where?: InputMaybe<User_WhereInput>;\\n  orderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;\\n  cursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;\\n  distinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;\\n  take?: InputMaybe<Scalars['Int']['input']>;\\n};\\n\\n\\nexport type Query_CompaniesArgs = {\\n  where?: InputMaybe<Company_WhereInput>;\\n  orderBy?: InputMaybe<ReadonlyArray<Company_OrderByInput>>;\\n  cursor?: InputMaybe<Company_WhereUnfilteredUniqueInput>;\\n  distinct?: InputMaybe<ReadonlyArray<Company_DistinctInput>>;\\n  take?: InputMaybe<Scalars['Int']['input']>;\\n};\\n\\nexport enum SortOrder {\\n  asc = 'asc',\\n  desc = 'desc'\\n}\\n\\nexport enum NullsOrder {\\n  first = 'first',\\n  last = 'last'\\n}\\n\\nexport enum User_DistinctInput {\\n  id = 'id',\\n  createdAt = 'createdAt',\\n  updatedAt = 'updatedAt',\\n  email = 'email',\\n  password = 'password',\\n  firstName = 'firstName',\\n  lastName = 'lastName',\\n  role = 'role',\\n  phoneNumber = 'phoneNumber'\\n}\\n\\nexport enum Company_DistinctInput {\\n  id = 'id',\\n  createdAt = 'createdAt',\\n  updatedAt = 'updatedAt',\\n  name = 'name'\\n}\\n\\nexport type _AllModels = {\\n  readonly User?: Maybe<User>;\\n  readonly Company?: Maybe<Company>;\\n};\\n\\nexport type User = {\\n  readonly id: Scalars['ID']['output'];\\n  readonly createdAt: Scalars['DateTime']['output'];\\n  readonly updatedAt: Scalars['DateTime']['output'];\\n  readonly email: Scalars['String']['output'];\\n  readonly password: Scalars['String']['output'];\\n  readonly firstName?: Maybe<Scalars['String']['output']>;\\n  readonly lastName?: Maybe<Scalars['String']['output']>;\\n  readonly role?: Maybe<Scalars['String']['output']>;\\n  readonly phoneNumber?: Maybe<Scalars['String']['output']>;\\n};\\n\\nexport type SortOrderWithNulls = {\\n  readonly sort: SortOrder | \`\${SortOrder}\`;\\n  readonly nulls?: InputMaybe<NullsOrder | \`\${NullsOrder}\`>;\\n};\\n\\nexport type User_Output = {\\n  readonly total: Scalars['Int']['output'];\\n  readonly items: ReadonlyArray<User>;\\n  readonly messages: ReadonlyArray<Maybe<OutputMessage>>;\\n};\\n\\nexport type OutputMessage = {\\n  readonly code: Scalars['String']['output'];\\n  readonly message: Scalars['String']['output'];\\n  readonly description: Scalars['String']['output'];\\n};\\n\\nexport type OrderByCount = {\\n  readonly _count?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n};\\n\\nexport type User_WhereInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly id?: InputMaybe<ID_WhereInput>;\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly email?: InputMaybe<String_WhereInput>;\\n  readonly password?: InputMaybe<String_WhereInput>;\\n  readonly firstName?: InputMaybe<String_WhereInput>;\\n  readonly lastName?: InputMaybe<String_WhereInput>;\\n  readonly role?: InputMaybe<String_WhereInput>;\\n  readonly phoneNumber?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type User_OrderByInput = {\\n  readonly id?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly createdAt?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly updatedAt?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly email?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly password?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly firstName?: InputMaybe<SortOrderWithNulls>;\\n  readonly lastName?: InputMaybe<SortOrderWithNulls>;\\n  readonly role?: InputMaybe<SortOrderWithNulls>;\\n  readonly phoneNumber?: InputMaybe<SortOrderWithNulls>;\\n};\\n\\nexport type User_WhereUnfilteredUniqueInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly email?: InputMaybe<String_WhereInput>;\\n  readonly password?: InputMaybe<String_WhereInput>;\\n  readonly firstName?: InputMaybe<String_WhereInput>;\\n  readonly lastName?: InputMaybe<String_WhereInput>;\\n  readonly role?: InputMaybe<String_WhereInput>;\\n  readonly phoneNumber?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type ID_WhereInput = {\\n  readonly equals?: InputMaybe<Scalars['ID']['input']>;\\n  readonly in?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;\\n  readonly notIn?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;\\n  readonly lt?: InputMaybe<Scalars['ID']['input']>;\\n  readonly lte?: InputMaybe<Scalars['ID']['input']>;\\n  readonly gt?: InputMaybe<Scalars['ID']['input']>;\\n  readonly gte?: InputMaybe<Scalars['ID']['input']>;\\n  readonly not?: InputMaybe<ID_WhereInput>;\\n  readonly contains?: InputMaybe<Scalars['ID']['input']>;\\n  readonly startsWith?: InputMaybe<Scalars['ID']['input']>;\\n  readonly endsWith?: InputMaybe<Scalars['ID']['input']>;\\n};\\n\\nexport type DateTime_WhereInput = {\\n  readonly equals?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\\n  readonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;\\n  readonly lt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly lte?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly gt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly gte?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly not?: InputMaybe<DateTime_WhereInput>;\\n};\\n\\nexport type String_WhereInput = {\\n  readonly equals?: InputMaybe<Scalars['String']['input']>;\\n  readonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\\n  readonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;\\n  readonly lt?: InputMaybe<Scalars['String']['input']>;\\n  readonly lte?: InputMaybe<Scalars['String']['input']>;\\n  readonly gt?: InputMaybe<Scalars['String']['input']>;\\n  readonly gte?: InputMaybe<Scalars['String']['input']>;\\n  readonly not?: InputMaybe<String_WhereInput>;\\n  readonly contains?: InputMaybe<Scalars['String']['input']>;\\n  readonly startsWith?: InputMaybe<Scalars['String']['input']>;\\n  readonly endsWith?: InputMaybe<Scalars['String']['input']>;\\n};\\n\\nexport type User_WhereManyInput = {\\n  readonly every?: InputMaybe<User_WhereInput>;\\n  readonly none?: InputMaybe<User_WhereInput>;\\n  readonly some?: InputMaybe<User_WhereInput>;\\n};\\n\\nexport type User_CreateInput = {\\n  readonly data: ReadonlyArray<User_CreateDataInput>;\\n};\\n\\nexport type User_UpdateInput = {\\n  readonly data: User_UpdateDataInput;\\n  readonly where: User_WhereUnfilteredUniqueInput;\\n};\\n\\nexport type User_UpsertInput = {\\n  readonly data: User_UpdateDataInput;\\n  readonly where: User_WhereRequiredProvidedUniqueInput;\\n};\\n\\nexport type User_DeleteInput = {\\n  readonly where: User_WhereInput;\\n};\\n\\nexport type User_WhereRequiredProvidedUniqueInput = {\\n  readonly id: Scalars['String']['input'];\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly email?: InputMaybe<String_WhereInput>;\\n  readonly password?: InputMaybe<String_WhereInput>;\\n  readonly firstName?: InputMaybe<String_WhereInput>;\\n  readonly lastName?: InputMaybe<String_WhereInput>;\\n  readonly role?: InputMaybe<String_WhereInput>;\\n  readonly phoneNumber?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type User_CreateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly email: Scalars['String']['input'];\\n  readonly password: Scalars['String']['input'];\\n  readonly firstName?: InputMaybe<Scalars['String']['input']>;\\n  readonly lastName?: InputMaybe<Scalars['String']['input']>;\\n  readonly role?: InputMaybe<Scalars['String']['input']>;\\n  readonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\\n};\\n\\nexport type User_UpdateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly email?: InputMaybe<Scalars['String']['input']>;\\n  readonly password?: InputMaybe<Scalars['String']['input']>;\\n  readonly firstName?: InputMaybe<Scalars['String']['input']>;\\n  readonly lastName?: InputMaybe<Scalars['String']['input']>;\\n  readonly role?: InputMaybe<Scalars['String']['input']>;\\n  readonly phoneNumber?: InputMaybe<Scalars['String']['input']>;\\n};\\n\\nexport type Company = {\\n  readonly id: Scalars['ID']['output'];\\n  readonly createdAt: Scalars['DateTime']['output'];\\n  readonly updatedAt: Scalars['DateTime']['output'];\\n  readonly name: Scalars['String']['output'];\\n};\\n\\nexport type Company_Output = {\\n  readonly total: Scalars['Int']['output'];\\n  readonly items: ReadonlyArray<Company>;\\n  readonly messages: ReadonlyArray<Maybe<OutputMessage>>;\\n};\\n\\nexport type Company_WhereInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly id?: InputMaybe<ID_WhereInput>;\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly name?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type Company_OrderByInput = {\\n  readonly id?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly createdAt?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly updatedAt?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly name?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n};\\n\\nexport type Company_WhereUnfilteredUniqueInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<Company_WhereInput>>;\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly name?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type Company_WhereManyInput = {\\n  readonly every?: InputMaybe<Company_WhereInput>;\\n  readonly none?: InputMaybe<Company_WhereInput>;\\n  readonly some?: InputMaybe<Company_WhereInput>;\\n};\\n\\nexport type Company_CreateInput = {\\n  readonly data: ReadonlyArray<Company_CreateDataInput>;\\n};\\n\\nexport type Company_UpdateInput = {\\n  readonly data: Company_UpdateDataInput;\\n  readonly where: Company_WhereUnfilteredUniqueInput;\\n};\\n\\nexport type Company_UpsertInput = {\\n  readonly data: Company_UpdateDataInput;\\n  readonly where: Company_WhereRequiredProvidedUniqueInput;\\n};\\n\\nexport type Company_DeleteInput = {\\n  readonly where: Company_WhereInput;\\n};\\n\\nexport type Company_WhereRequiredProvidedUniqueInput = {\\n  readonly id: Scalars['String']['input'];\\n  readonly createdAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly updatedAt?: InputMaybe<DateTime_WhereInput>;\\n  readonly name?: InputMaybe<String_WhereInput>;\\n};\\n\\nexport type Company_CreateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly name: Scalars['String']['input'];\\n};\\n\\nexport type Company_UpdateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;\\n  readonly name?: InputMaybe<Scalars['String']['input']>;\\n};\\n\\n\\n\\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\\n\\n\\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\\n};\\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\\n\\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => Promise<TResult> | TResult;\\n\\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\\n\\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => TResult | Promise<TResult>;\\n\\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\\n  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\\n  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\\n}\\n\\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\\n}\\n\\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\\n\\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\\n  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\\n\\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\\n  parent: TParent,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\\n\\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\\n\\nexport type NextResolverFn<T> = () => Promise<T>;\\n\\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\\n  next: NextResolverFn<TResult>,\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => TResult | Promise<TResult>;\\n\\n\\n\\n/** Mapping between all available schema types and the resolvers types */\\nexport type ResolversTypes = {\\n  Mutation: ResolverTypeWrapper<{}>;\\n  Query: ResolverTypeWrapper<{}>;\\n  Int: ResolverTypeWrapper<Scalars['Int']['output']>;\\n  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;\\n  SortOrder: SortOrder;\\n  NullsOrder: NullsOrder;\\n  User_DistinctInput: User_DistinctInput;\\n  Company_DistinctInput: Company_DistinctInput;\\n  _AllModels: ResolverTypeWrapper<_AllModels>;\\n  User: ResolverTypeWrapper<User>;\\n  ID: ResolverTypeWrapper<Scalars['ID']['output']>;\\n  String: ResolverTypeWrapper<Scalars['String']['output']>;\\n  SortOrderWithNulls: SortOrderWithNulls;\\n  User_Output: ResolverTypeWrapper<User_Output>;\\n  OutputMessage: ResolverTypeWrapper<OutputMessage>;\\n  OrderByCount: OrderByCount;\\n  User_WhereInput: User_WhereInput;\\n  User_OrderByInput: User_OrderByInput;\\n  User_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\\n  ID_WhereInput: ID_WhereInput;\\n  DateTime_WhereInput: DateTime_WhereInput;\\n  String_WhereInput: String_WhereInput;\\n  User_WhereManyInput: User_WhereManyInput;\\n  User_CreateInput: User_CreateInput;\\n  User_UpdateInput: User_UpdateInput;\\n  User_UpsertInput: User_UpsertInput;\\n  User_DeleteInput: User_DeleteInput;\\n  User_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\\n  User_CreateDataInput: User_CreateDataInput;\\n  User_UpdateDataInput: User_UpdateDataInput;\\n  Company: ResolverTypeWrapper<Company>;\\n  Company_Output: ResolverTypeWrapper<Company_Output>;\\n  Company_WhereInput: Company_WhereInput;\\n  Company_OrderByInput: Company_OrderByInput;\\n  Company_WhereUnfilteredUniqueInput: Company_WhereUnfilteredUniqueInput;\\n  Company_WhereManyInput: Company_WhereManyInput;\\n  Company_CreateInput: Company_CreateInput;\\n  Company_UpdateInput: Company_UpdateInput;\\n  Company_UpsertInput: Company_UpsertInput;\\n  Company_DeleteInput: Company_DeleteInput;\\n  Company_WhereRequiredProvidedUniqueInput: Company_WhereRequiredProvidedUniqueInput;\\n  Company_CreateDataInput: Company_CreateDataInput;\\n  Company_UpdateDataInput: Company_UpdateDataInput;\\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\\n};\\n\\n/** Mapping between all available schema types and the resolvers parents */\\nexport type ResolversParentTypes = {\\n  Mutation: {};\\n  Query: {};\\n  Int: Scalars['Int']['output'];\\n  DateTime: Scalars['DateTime']['output'];\\n  _AllModels: _AllModels;\\n  User: User;\\n  ID: Scalars['ID']['output'];\\n  String: Scalars['String']['output'];\\n  SortOrderWithNulls: SortOrderWithNulls;\\n  User_Output: User_Output;\\n  OutputMessage: OutputMessage;\\n  OrderByCount: OrderByCount;\\n  User_WhereInput: User_WhereInput;\\n  User_OrderByInput: User_OrderByInput;\\n  User_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;\\n  ID_WhereInput: ID_WhereInput;\\n  DateTime_WhereInput: DateTime_WhereInput;\\n  String_WhereInput: String_WhereInput;\\n  User_WhereManyInput: User_WhereManyInput;\\n  User_CreateInput: User_CreateInput;\\n  User_UpdateInput: User_UpdateInput;\\n  User_UpsertInput: User_UpsertInput;\\n  User_DeleteInput: User_DeleteInput;\\n  User_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;\\n  User_CreateDataInput: User_CreateDataInput;\\n  User_UpdateDataInput: User_UpdateDataInput;\\n  Company: Company;\\n  Company_Output: Company_Output;\\n  Company_WhereInput: Company_WhereInput;\\n  Company_OrderByInput: Company_OrderByInput;\\n  Company_WhereUnfilteredUniqueInput: Company_WhereUnfilteredUniqueInput;\\n  Company_WhereManyInput: Company_WhereManyInput;\\n  Company_CreateInput: Company_CreateInput;\\n  Company_UpdateInput: Company_UpdateInput;\\n  Company_UpsertInput: Company_UpsertInput;\\n  Company_DeleteInput: Company_DeleteInput;\\n  Company_WhereRequiredProvidedUniqueInput: Company_WhereRequiredProvidedUniqueInput;\\n  Company_CreateDataInput: Company_CreateDataInput;\\n  Company_UpdateDataInput: Company_UpdateDataInput;\\n  Boolean: Scalars['Boolean']['output'];\\n};\\n\\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\\n  Users?: Resolver<ResolversTypes['User_Output'], ParentType, ContextType, Partial<Mutation_UsersArgs>>;\\n  Companies?: Resolver<ResolversTypes['Company_Output'], ParentType, ContextType, Partial<Mutation_CompaniesArgs>>;\\n};\\n\\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\\n  Users?: Resolver<ResolversTypes['User_Output'], ParentType, ContextType, Partial<Query_UsersArgs>>;\\n  Companies?: Resolver<ResolversTypes['Company_Output'], ParentType, ContextType, Partial<Query_CompaniesArgs>>;\\n};\\n\\nexport interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {\\n  name: 'DateTime';\\n}\\n\\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\\n  User?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;\\n  Company?: Resolver<Maybe<ResolversTypes['Company']>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\\n  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\\n  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\\n  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\\n  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\\n  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\\n  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\\n  phoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type User_OutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['User_Output'] = ResolversParentTypes['User_Output']> = {\\n  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\\n  items?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;\\n  messages?: Resolver<ReadonlyArray<Maybe<ResolversTypes['OutputMessage']>>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type OutputMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['OutputMessage'] = ResolversParentTypes['OutputMessage']> = {\\n  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type CompanyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Company'] = ResolversParentTypes['Company']> = {\\n  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\\n  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\\n  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;\\n  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type Company_OutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['Company_Output'] = ResolversParentTypes['Company_Output']> = {\\n  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\\n  items?: Resolver<ReadonlyArray<ResolversTypes['Company']>, ParentType, ContextType>;\\n  messages?: Resolver<ReadonlyArray<Maybe<ResolversTypes['OutputMessage']>>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type Resolvers<ContextType = any> = {\\n  Mutation?: MutationResolvers<ContextType>;\\n  Query?: QueryResolvers<ContextType>;\\n  DateTime?: GraphQLScalarType;\\n  _AllModels?: _AllModelsResolvers<ContextType>;\\n  User?: UserResolvers<ContextType>;\\n  User_Output?: User_OutputResolvers<ContextType>;\\n  OutputMessage?: OutputMessageResolvers<ContextType>;\\n  Company?: CompanyResolvers<ContextType>;\\n  Company_Output?: Company_OutputResolvers<ContextType>;\\n};\\n\\n\\nimport type {SchemaOperationTypeNames} from '@prisma-to-graphql/core';\\n\\nexport const schemaOperationTypeNames: Readonly<SchemaOperationTypeNames> = {\\n    Mutation: {\\n        Users: {\\n            args: {\\n                create: 'User_CreateInput',\\n                update: 'User_UpdateInput',\\n                upsert: 'User_UpsertInput',\\n                delete: 'User_DeleteInput',\\n            },\\n            output: 'User_Output!',\\n        },\\n        Companies: {\\n            args: {\\n                create: 'Company_CreateInput',\\n                update: 'Company_UpdateInput',\\n                upsert: 'Company_UpsertInput',\\n                delete: 'Company_DeleteInput',\\n            },\\n            output: 'Company_Output!',\\n        },\\n    },\\n    Query: {\\n        Users: {\\n            args: {\\n                where: 'User_WhereInput',\\n                orderBy: '[User_OrderByInput!]',\\n                cursor: 'User_WhereUnfilteredUniqueInput',\\n                distinct: '[User_DistinctInput!]',\\n                take: 'Int',\\n            },\\n            output: 'User_Output!',\\n        },\\n        Companies: {\\n            args: {\\n                where: 'Company_WhereInput',\\n                orderBy: '[Company_OrderByInput!]',\\n                cursor: 'Company_WhereUnfilteredUniqueInput',\\n                distinct: '[Company_DistinctInput!]',\\n                take: 'Int',\\n            },\\n            output: 'Company_Output!',\\n        },\\n    },\\n};"
`;

exports[`buildSchemaTs > scalar-list 1`] = `
"// generated by prisma-to-graphql\\n\\nimport type { GraphQLResolveInfo } from 'graphql';\\nexport type Maybe<T> = T | null | undefined;\\nexport type InputMaybe<T> = T | null | undefined;\\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\\n/** All built-in and custom scalars, mapped to their actual values */\\nexport type Scalars = {\\n  ID: { input: string; output: string; }\\n  String: { input: string; output: string; }\\n  Boolean: { input: boolean; output: boolean; }\\n  Int: { input: number; output: number; }\\n  Float: { input: number; output: number; }\\n};\\n\\nexport type Mutation = {\\n  readonly SomeModels: SomeModel_Output;\\n};\\n\\n\\nexport type Mutation_SomeModelsArgs = {\\n  create?: InputMaybe<SomeModel_CreateInput>;\\n  update?: InputMaybe<SomeModel_UpdateInput>;\\n  upsert?: InputMaybe<SomeModel_UpsertInput>;\\n  delete?: InputMaybe<SomeModel_DeleteInput>;\\n};\\n\\nexport type Query = {\\n  readonly SomeModels: SomeModel_Output;\\n};\\n\\n\\nexport type Query_SomeModelsArgs = {\\n  where?: InputMaybe<SomeModel_WhereInput>;\\n  orderBy?: InputMaybe<ReadonlyArray<SomeModel_OrderByInput>>;\\n  cursor?: InputMaybe<SomeModel_WhereUnfilteredUniqueInput>;\\n  distinct?: InputMaybe<ReadonlyArray<SomeModel_DistinctInput>>;\\n  take?: InputMaybe<Scalars['Int']['input']>;\\n};\\n\\nexport enum SortOrder {\\n  asc = 'asc',\\n  desc = 'desc'\\n}\\n\\nexport enum NullsOrder {\\n  first = 'first',\\n  last = 'last'\\n}\\n\\nexport enum SomeModel_DistinctInput {\\n  id = 'id',\\n  multiScalar = 'multiScalar'\\n}\\n\\nexport type _AllModels = {\\n  readonly SomeModel?: Maybe<SomeModel>;\\n};\\n\\nexport type SomeModel = {\\n  readonly id: Scalars['ID']['output'];\\n  readonly multiScalar: ReadonlyArray<Maybe<Scalars['String']['output']>>;\\n};\\n\\nexport type SortOrderWithNulls = {\\n  readonly sort: SortOrder | \`\${SortOrder}\`;\\n  readonly nulls?: InputMaybe<NullsOrder | \`\${NullsOrder}\`>;\\n};\\n\\nexport type SomeModel_Output = {\\n  readonly total: Scalars['Int']['output'];\\n  readonly items: ReadonlyArray<SomeModel>;\\n  readonly messages: ReadonlyArray<Maybe<OutputMessage>>;\\n};\\n\\nexport type OutputMessage = {\\n  readonly code: Scalars['String']['output'];\\n  readonly message: Scalars['String']['output'];\\n  readonly description: Scalars['String']['output'];\\n};\\n\\nexport type OrderByCount = {\\n  readonly _count?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n};\\n\\nexport type SomeModel_WhereInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly id?: InputMaybe<ID_WhereInput>;\\n  readonly multiScalar?: InputMaybe<String_WhereManyInput>;\\n};\\n\\nexport type SomeModel_OrderByInput = {\\n  readonly id?: InputMaybe<SortOrder | \`\${SortOrder}\`>;\\n  readonly multiScalar?: InputMaybe<OrderByCount>;\\n};\\n\\nexport type SomeModel_WhereUnfilteredUniqueInput = {\\n  readonly AND?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly OR?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly NOT?: InputMaybe<ReadonlyArray<SomeModel_WhereInput>>;\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly multiScalar?: InputMaybe<String_WhereManyInput>;\\n};\\n\\nexport type ID_WhereInput = {\\n  readonly equals?: InputMaybe<Scalars['ID']['input']>;\\n  readonly in?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;\\n  readonly notIn?: InputMaybe<ReadonlyArray<Scalars['ID']['input']>>;\\n  readonly lt?: InputMaybe<Scalars['ID']['input']>;\\n  readonly lte?: InputMaybe<Scalars['ID']['input']>;\\n  readonly gt?: InputMaybe<Scalars['ID']['input']>;\\n  readonly gte?: InputMaybe<Scalars['ID']['input']>;\\n  readonly not?: InputMaybe<ID_WhereInput>;\\n  readonly contains?: InputMaybe<Scalars['ID']['input']>;\\n  readonly startsWith?: InputMaybe<Scalars['ID']['input']>;\\n  readonly endsWith?: InputMaybe<Scalars['ID']['input']>;\\n};\\n\\nexport type String_WhereManyInput = {\\n  readonly equals?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;\\n  readonly has?: InputMaybe<Scalars['String']['input']>;\\n  readonly hasEvery?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;\\n  readonly hasSome?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;\\n  readonly isEmpty?: InputMaybe<Scalars['Boolean']['input']>;\\n};\\n\\nexport type SomeModel_WhereManyInput = {\\n  readonly every?: InputMaybe<SomeModel_WhereInput>;\\n  readonly none?: InputMaybe<SomeModel_WhereInput>;\\n  readonly some?: InputMaybe<SomeModel_WhereInput>;\\n};\\n\\nexport type SomeModel_CreateInput = {\\n  readonly data: ReadonlyArray<SomeModel_CreateDataInput>;\\n};\\n\\nexport type SomeModel_UpdateInput = {\\n  readonly data: SomeModel_UpdateDataInput;\\n  readonly where: SomeModel_WhereUnfilteredUniqueInput;\\n};\\n\\nexport type SomeModel_UpsertInput = {\\n  readonly data: SomeModel_UpdateDataInput;\\n  readonly where: SomeModel_WhereRequiredProvidedUniqueInput;\\n};\\n\\nexport type SomeModel_DeleteInput = {\\n  readonly where: SomeModel_WhereInput;\\n};\\n\\nexport type SomeModel_WhereRequiredProvidedUniqueInput = {\\n  readonly id: Scalars['String']['input'];\\n  readonly multiScalar?: InputMaybe<String_WhereManyInput>;\\n};\\n\\nexport type SomeModel_CreateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly multiScalar: Scalars['String']['input'];\\n};\\n\\nexport type SomeModel_UpdateDataInput = {\\n  readonly id?: InputMaybe<Scalars['String']['input']>;\\n  readonly multiScalar?: InputMaybe<Scalars['String']['input']>;\\n};\\n\\n\\n\\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\\n\\n\\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\\n};\\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\\n\\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => Promise<TResult> | TResult;\\n\\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\\n\\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => TResult | Promise<TResult>;\\n\\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\\n  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\\n  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\\n}\\n\\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\\n}\\n\\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\\n\\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\\n  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\\n\\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\\n  parent: TParent,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\\n\\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\\n\\nexport type NextResolverFn<T> = () => Promise<T>;\\n\\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\\n  next: NextResolverFn<TResult>,\\n  parent: TParent,\\n  args: TArgs,\\n  context: TContext,\\n  info: GraphQLResolveInfo\\n) => TResult | Promise<TResult>;\\n\\n\\n\\n/** Mapping between all available schema types and the resolvers types */\\nexport type ResolversTypes = {\\n  Mutation: ResolverTypeWrapper<{}>;\\n  Query: ResolverTypeWrapper<{}>;\\n  Int: ResolverTypeWrapper<Scalars['Int']['output']>;\\n  SortOrder: SortOrder;\\n  NullsOrder: NullsOrder;\\n  SomeModel_DistinctInput: SomeModel_DistinctInput;\\n  _AllModels: ResolverTypeWrapper<_AllModels>;\\n  SomeModel: ResolverTypeWrapper<SomeModel>;\\n  ID: ResolverTypeWrapper<Scalars['ID']['output']>;\\n  String: ResolverTypeWrapper<Scalars['String']['output']>;\\n  SortOrderWithNulls: SortOrderWithNulls;\\n  SomeModel_Output: ResolverTypeWrapper<SomeModel_Output>;\\n  OutputMessage: ResolverTypeWrapper<OutputMessage>;\\n  OrderByCount: OrderByCount;\\n  SomeModel_WhereInput: SomeModel_WhereInput;\\n  SomeModel_OrderByInput: SomeModel_OrderByInput;\\n  SomeModel_WhereUnfilteredUniqueInput: SomeModel_WhereUnfilteredUniqueInput;\\n  ID_WhereInput: ID_WhereInput;\\n  String_WhereManyInput: String_WhereManyInput;\\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;\\n  SomeModel_WhereManyInput: SomeModel_WhereManyInput;\\n  SomeModel_CreateInput: SomeModel_CreateInput;\\n  SomeModel_UpdateInput: SomeModel_UpdateInput;\\n  SomeModel_UpsertInput: SomeModel_UpsertInput;\\n  SomeModel_DeleteInput: SomeModel_DeleteInput;\\n  SomeModel_WhereRequiredProvidedUniqueInput: SomeModel_WhereRequiredProvidedUniqueInput;\\n  SomeModel_CreateDataInput: SomeModel_CreateDataInput;\\n  SomeModel_UpdateDataInput: SomeModel_UpdateDataInput;\\n};\\n\\n/** Mapping between all available schema types and the resolvers parents */\\nexport type ResolversParentTypes = {\\n  Mutation: {};\\n  Query: {};\\n  Int: Scalars['Int']['output'];\\n  _AllModels: _AllModels;\\n  SomeModel: SomeModel;\\n  ID: Scalars['ID']['output'];\\n  String: Scalars['String']['output'];\\n  SortOrderWithNulls: SortOrderWithNulls;\\n  SomeModel_Output: SomeModel_Output;\\n  OutputMessage: OutputMessage;\\n  OrderByCount: OrderByCount;\\n  SomeModel_WhereInput: SomeModel_WhereInput;\\n  SomeModel_OrderByInput: SomeModel_OrderByInput;\\n  SomeModel_WhereUnfilteredUniqueInput: SomeModel_WhereUnfilteredUniqueInput;\\n  ID_WhereInput: ID_WhereInput;\\n  String_WhereManyInput: String_WhereManyInput;\\n  Boolean: Scalars['Boolean']['output'];\\n  SomeModel_WhereManyInput: SomeModel_WhereManyInput;\\n  SomeModel_CreateInput: SomeModel_CreateInput;\\n  SomeModel_UpdateInput: SomeModel_UpdateInput;\\n  SomeModel_UpsertInput: SomeModel_UpsertInput;\\n  SomeModel_DeleteInput: SomeModel_DeleteInput;\\n  SomeModel_WhereRequiredProvidedUniqueInput: SomeModel_WhereRequiredProvidedUniqueInput;\\n  SomeModel_CreateDataInput: SomeModel_CreateDataInput;\\n  SomeModel_UpdateDataInput: SomeModel_UpdateDataInput;\\n};\\n\\nexport type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {\\n  SomeModels?: Resolver<ResolversTypes['SomeModel_Output'], ParentType, ContextType, Partial<Mutation_SomeModelsArgs>>;\\n};\\n\\nexport type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\\n  SomeModels?: Resolver<ResolversTypes['SomeModel_Output'], ParentType, ContextType, Partial<Query_SomeModelsArgs>>;\\n};\\n\\nexport type _AllModelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels']> = {\\n  SomeModel?: Resolver<Maybe<ResolversTypes['SomeModel']>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type SomeModelResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeModel'] = ResolversParentTypes['SomeModel']> = {\\n  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\\n  multiScalar?: Resolver<ReadonlyArray<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type SomeModel_OutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeModel_Output'] = ResolversParentTypes['SomeModel_Output']> = {\\n  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\\n  items?: Resolver<ReadonlyArray<ResolversTypes['SomeModel']>, ParentType, ContextType>;\\n  messages?: Resolver<ReadonlyArray<Maybe<ResolversTypes['OutputMessage']>>, ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type OutputMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['OutputMessage'] = ResolversParentTypes['OutputMessage']> = {\\n  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\\n};\\n\\nexport type Resolvers<ContextType = any> = {\\n  Mutation?: MutationResolvers<ContextType>;\\n  Query?: QueryResolvers<ContextType>;\\n  _AllModels?: _AllModelsResolvers<ContextType>;\\n  SomeModel?: SomeModelResolvers<ContextType>;\\n  SomeModel_Output?: SomeModel_OutputResolvers<ContextType>;\\n  OutputMessage?: OutputMessageResolvers<ContextType>;\\n};\\n\\n\\nimport type {SchemaOperationTypeNames} from '@prisma-to-graphql/core';\\n\\nexport const schemaOperationTypeNames: Readonly<SchemaOperationTypeNames> = {\\n    Mutation: {\\n        SomeModels: {\\n            args: {\\n                create: 'SomeModel_CreateInput',\\n                update: 'SomeModel_UpdateInput',\\n                upsert: 'SomeModel_UpsertInput',\\n                delete: 'SomeModel_DeleteInput',\\n            },\\n            output: 'SomeModel_Output!',\\n        },\\n    },\\n    Query: {\\n        SomeModels: {\\n            args: {\\n                where: 'SomeModel_WhereInput',\\n                orderBy: '[SomeModel_OrderByInput!]',\\n                cursor: 'SomeModel_WhereUnfilteredUniqueInput',\\n                distinct: '[SomeModel_DistinctInput!]',\\n                take: 'Int',\\n            },\\n            output: 'SomeModel_Output!',\\n        },\\n    },\\n};"
`;
