// generated by prisma-to-graphql

import type {UtcIsoString} from 'date-vir';
import type {GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig} from 'graphql';
export type Maybe<T> = T | null | undefined;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends {[key: string]: unknown}> = {[K in keyof T]: T[K]};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {[SubKey in K]?: Maybe<T[SubKey]>};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {[SubKey in K]: Maybe<T[SubKey]>};
export type MakeEmpty<T extends {[key: string]: unknown}, K extends keyof T> = {[_ in K]?: never};
export type Incremental<T> =
    | T
    | {[P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {[P in K]-?: NonNullable<T[P]>};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {input: string; output: string};
    String: {input: string; output: string};
    Boolean: {input: boolean; output: boolean};
    Int: {input: number; output: number};
    Float: {input: number; output: number};
    DateTime: {input: string | Date; output: UtcIsoString};
};

export type Mutation = {
    readonly Users: User_QueryOutput;
    readonly UserSettings: UserSettings_QueryOutput;
    readonly UserStats: UserStats_QueryOutput;
};

export type Mutation_UsersArgs = {
    create?: InputMaybe<User_CreateInput>;
    update?: InputMaybe<User_UpdateInput>;
    upsert?: InputMaybe<User_UpsertInput>;
};

export type Mutation_UserSettingsArgs = {
    create?: InputMaybe<UserSettings_CreateInput>;
    update?: InputMaybe<UserSettings_UpdateInput>;
    upsert?: InputMaybe<UserSettings_UpsertInput>;
};

export type Mutation_UserStatsArgs = {
    create?: InputMaybe<UserStats_CreateInput>;
    update?: InputMaybe<UserStats_UpdateInput>;
    upsert?: InputMaybe<UserStats_UpsertInput>;
};

export type Query = {
    readonly Users: User_QueryOutput;
    readonly UserSettings: UserSettings_QueryOutput;
    readonly UserStats: UserStats_QueryOutput;
};

export type Query_UsersArgs = {
    where: User_WhereInput;
    orderBy?: InputMaybe<ReadonlyArray<User_OrderByInput>>;
    cursor?: InputMaybe<User_WhereUnfilteredUniqueInput>;
    distinct?: InputMaybe<ReadonlyArray<User_DistinctInput>>;
    take?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
};

export type Query_UserSettingsArgs = {
    where: UserSettings_WhereInput;
    orderBy?: InputMaybe<ReadonlyArray<UserSettings_OrderByInput>>;
    cursor?: InputMaybe<UserSettings_WhereUnfilteredUniqueInput>;
    distinct?: InputMaybe<ReadonlyArray<UserSettings_DistinctInput>>;
    take?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
};

export type Query_UserStatsArgs = {
    where: UserStats_WhereInput;
    orderBy?: InputMaybe<ReadonlyArray<UserStats_OrderByInput>>;
    cursor?: InputMaybe<UserStats_WhereUnfilteredUniqueInput>;
    distinct?: InputMaybe<ReadonlyArray<UserStats_DistinctInput>>;
    take?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
};

export enum SortOrder {
    asc = 'asc',
    desc = 'desc',
}

export enum NullsOrder {
    first = 'first',
    last = 'last',
}

export enum User_DistinctInput {
    id = 'id',
    createdAt = 'createdAt',
    updatedAt = 'updatedAt',
    email = 'email',
    password = 'password',
    firstName = 'firstName',
    lastName = 'lastName',
    role = 'role',
    phoneNumber = 'phoneNumber',
}

export enum UserSettings_DistinctInput {
    id = 'id',
    createdAt = 'createdAt',
    updatedAt = 'updatedAt',
    receivesMarketingEmails = 'receivesMarketingEmails',
    canViewReports = 'canViewReports',
}

export enum UserStats_DistinctInput {
    id = 'id',
    createdAt = 'createdAt',
    updatedAt = 'updatedAt',
    likes = 'likes',
    dislikes = 'dislikes',
    views = 'views',
}

export type _AllModels = {
    readonly User?: Maybe<User>;
    readonly UserSettings?: Maybe<UserSettings>;
    readonly UserStats?: Maybe<UserStats>;
};

export type User = {
    readonly id: Scalars['String']['output'];
    readonly createdAt: Scalars['DateTime']['output'];
    readonly updatedAt: Scalars['DateTime']['output'];
    readonly email: Scalars['String']['output'];
    readonly password: Scalars['String']['output'];
    readonly firstName?: Maybe<Scalars['String']['output']>;
    readonly lastName?: Maybe<Scalars['String']['output']>;
    readonly role?: Maybe<Scalars['String']['output']>;
    readonly phoneNumber?: Maybe<Scalars['String']['output']>;
    readonly settings?: Maybe<UserSettings>;
};

export type SortOrderWithNulls = {
    readonly sort: SortOrder | `${SortOrder}`;
    readonly nulls?: InputMaybe<NullsOrder | `${NullsOrder}`>;
};

export type User_QueryOutput = {
    readonly total: Scalars['Int']['output'];
    readonly items: ReadonlyArray<User>;
};

export type User_WhereInput = {
    readonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly id?: InputMaybe<StringFilterInput>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly email?: InputMaybe<StringFilterInput>;
    readonly password?: InputMaybe<StringFilterInput>;
    readonly firstName?: InputMaybe<StringFilterInput>;
    readonly lastName?: InputMaybe<StringFilterInput>;
    readonly role?: InputMaybe<StringFilterInput>;
    readonly phoneNumber?: InputMaybe<StringFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type User_OrderByInput = {
    readonly id?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly email?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly password?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly firstName?: InputMaybe<SortOrderWithNulls>;
    readonly lastName?: InputMaybe<SortOrderWithNulls>;
    readonly role?: InputMaybe<SortOrderWithNulls>;
    readonly phoneNumber?: InputMaybe<SortOrderWithNulls>;
    readonly settings?: InputMaybe<UserSettings_OrderByInput>;
};

export type User_WhereUnfilteredUniqueInput = {
    readonly AND?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<User_WhereInput>>;
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly email?: InputMaybe<StringFilterInput>;
    readonly password?: InputMaybe<StringFilterInput>;
    readonly firstName?: InputMaybe<StringFilterInput>;
    readonly lastName?: InputMaybe<StringFilterInput>;
    readonly role?: InputMaybe<StringFilterInput>;
    readonly phoneNumber?: InputMaybe<StringFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type StringFilterInput = {
    readonly equals?: InputMaybe<Scalars['String']['input']>;
    readonly in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
    readonly notIn?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
    readonly lt?: InputMaybe<Scalars['String']['input']>;
    readonly lte?: InputMaybe<Scalars['String']['input']>;
    readonly gt?: InputMaybe<Scalars['String']['input']>;
    readonly gte?: InputMaybe<Scalars['String']['input']>;
    readonly not?: InputMaybe<StringFilterInput>;
    readonly contains?: InputMaybe<Scalars['String']['input']>;
    readonly startsWith?: InputMaybe<Scalars['String']['input']>;
    readonly endsWith?: InputMaybe<Scalars['String']['input']>;
};

export type DateTimeFilterInput = {
    readonly equals?: InputMaybe<Scalars['DateTime']['input']>;
    readonly in?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;
    readonly notIn?: InputMaybe<ReadonlyArray<Scalars['DateTime']['input']>>;
    readonly lt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly lte?: InputMaybe<Scalars['DateTime']['input']>;
    readonly gt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly gte?: InputMaybe<Scalars['DateTime']['input']>;
    readonly not?: InputMaybe<DateTimeFilterInput>;
};

export type User_CreateInput = {
    readonly data: ReadonlyArray<User_CreateDataInput>;
};

export type User_UpdateInput = {
    readonly data: User_UpdateDataInput;
    readonly where: User_WhereUnfilteredUniqueInput;
};

export type User_UpsertInput = {
    readonly data: User_UpdateDataInput;
    readonly where: User_WhereRequiredProvidedUniqueInput;
};

export type User_WhereRequiredProvidedUniqueInput = {
    readonly id: Scalars['String']['input'];
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly email?: InputMaybe<StringFilterInput>;
    readonly password?: InputMaybe<StringFilterInput>;
    readonly firstName?: InputMaybe<StringFilterInput>;
    readonly lastName?: InputMaybe<StringFilterInput>;
    readonly role?: InputMaybe<StringFilterInput>;
    readonly phoneNumber?: InputMaybe<StringFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type User_CreateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly email: Scalars['String']['input'];
    readonly password: Scalars['String']['input'];
    readonly firstName?: InputMaybe<Scalars['String']['input']>;
    readonly lastName?: InputMaybe<Scalars['String']['input']>;
    readonly role?: InputMaybe<Scalars['String']['input']>;
    readonly phoneNumber?: InputMaybe<Scalars['String']['input']>;
    readonly settings?: InputMaybe<UserSettings_Without_User_ConnectionInput>;
};

export type User_UpdateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly email?: InputMaybe<Scalars['String']['input']>;
    readonly password?: InputMaybe<Scalars['String']['input']>;
    readonly firstName?: InputMaybe<Scalars['String']['input']>;
    readonly lastName?: InputMaybe<Scalars['String']['input']>;
    readonly role?: InputMaybe<Scalars['String']['input']>;
    readonly phoneNumber?: InputMaybe<Scalars['String']['input']>;
    readonly settings?: InputMaybe<UserSettings_Without_User_ConnectionInput>;
};

export type User_Without_UserSettings_CreateOrConnectInput = {
    readonly connect: User_WhereUnfilteredUniqueInput;
    readonly create: User_Without_UserSettings_CreateInput;
};

export type User_Without_UserSettings_CreateInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly email: Scalars['String']['input'];
    readonly password: Scalars['String']['input'];
    readonly firstName?: InputMaybe<Scalars['String']['input']>;
    readonly lastName?: InputMaybe<Scalars['String']['input']>;
    readonly role?: InputMaybe<Scalars['String']['input']>;
    readonly phoneNumber?: InputMaybe<Scalars['String']['input']>;
};

export type User_Without_UserSettings_ConnectionInput = {
    readonly create?: InputMaybe<User_Without_UserSettings_CreateInput>;
    readonly connectOrCreate?: InputMaybe<User_Without_UserSettings_CreateOrConnectInput>;
    readonly connect?: InputMaybe<User_WhereUnfilteredUniqueInput>;
};

export type UserSettings = {
    readonly id: Scalars['String']['output'];
    readonly createdAt: Scalars['DateTime']['output'];
    readonly updatedAt: Scalars['DateTime']['output'];
    readonly receivesMarketingEmails: Scalars['Boolean']['output'];
    readonly canViewReports: Scalars['Boolean']['output'];
    readonly stats?: Maybe<UserStats>;
    readonly user: User;
};

export type UserSettings_QueryOutput = {
    readonly total: Scalars['Int']['output'];
    readonly items: ReadonlyArray<UserSettings>;
};

export type UserSettings_WhereInput = {
    readonly AND?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly id?: InputMaybe<StringFilterInput>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly receivesMarketingEmails?: InputMaybe<BooleanFilterInput>;
    readonly canViewReports?: InputMaybe<BooleanFilterInput>;
    readonly stats?: InputMaybe<UserStats_WhereInput>;
    readonly user?: InputMaybe<User_WhereInput>;
};

export type UserSettings_OrderByInput = {
    readonly id?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly receivesMarketingEmails?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly canViewReports?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly stats?: InputMaybe<UserStats_OrderByInput>;
    readonly user?: InputMaybe<User_OrderByInput>;
};

export type UserSettings_WhereUnfilteredUniqueInput = {
    readonly AND?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<UserSettings_WhereInput>>;
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly receivesMarketingEmails?: InputMaybe<BooleanFilterInput>;
    readonly canViewReports?: InputMaybe<BooleanFilterInput>;
    readonly stats?: InputMaybe<UserStats_WhereInput>;
    readonly user?: InputMaybe<User_WhereInput>;
};

export type BooleanFilterInput = {
    readonly equals?: InputMaybe<Scalars['Boolean']['input']>;
    readonly not?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserSettings_CreateInput = {
    readonly data: ReadonlyArray<UserSettings_CreateDataInput>;
};

export type UserSettings_UpdateInput = {
    readonly data: UserSettings_UpdateDataInput;
    readonly where: UserSettings_WhereUnfilteredUniqueInput;
};

export type UserSettings_UpsertInput = {
    readonly data: UserSettings_UpdateDataInput;
    readonly where: UserSettings_WhereRequiredProvidedUniqueInput;
};

export type UserSettings_WhereRequiredProvidedUniqueInput = {
    readonly id: Scalars['String']['input'];
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly receivesMarketingEmails?: InputMaybe<BooleanFilterInput>;
    readonly canViewReports?: InputMaybe<BooleanFilterInput>;
    readonly stats?: InputMaybe<UserStats_WhereInput>;
    readonly user?: InputMaybe<User_WhereInput>;
};

export type UserSettings_CreateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly receivesMarketingEmails?: InputMaybe<Scalars['Boolean']['input']>;
    readonly canViewReports?: InputMaybe<Scalars['Boolean']['input']>;
    readonly stats?: InputMaybe<UserStats_Without_UserSettings_ConnectionInput>;
    readonly user: User_Without_UserSettings_ConnectionInput;
};

export type UserSettings_UpdateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly receivesMarketingEmails?: InputMaybe<Scalars['Boolean']['input']>;
    readonly canViewReports?: InputMaybe<Scalars['Boolean']['input']>;
    readonly stats?: InputMaybe<UserStats_Without_UserSettings_ConnectionInput>;
    readonly user?: InputMaybe<User_Without_UserSettings_ConnectionInput>;
};

export type UserSettings_Without_UserStats_CreateOrConnectInput = {
    readonly connect: UserSettings_WhereUnfilteredUniqueInput;
    readonly create: UserSettings_Without_UserStats_CreateInput;
};

export type UserSettings_Without_UserStats_CreateInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly receivesMarketingEmails?: InputMaybe<Scalars['Boolean']['input']>;
    readonly canViewReports?: InputMaybe<Scalars['Boolean']['input']>;
    readonly user: User_Without_UserSettings_CreateInput;
};

export type UserSettings_Without_UserStats_ConnectionInput = {
    readonly create?: InputMaybe<UserSettings_Without_UserStats_CreateInput>;
    readonly connectOrCreate?: InputMaybe<UserSettings_Without_UserStats_CreateOrConnectInput>;
    readonly connect?: InputMaybe<UserSettings_WhereUnfilteredUniqueInput>;
};

export type UserSettings_Without_User_CreateOrConnectInput = {
    readonly connect: UserSettings_WhereUnfilteredUniqueInput;
    readonly create: UserSettings_Without_User_CreateInput;
};

export type UserSettings_Without_User_CreateInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly receivesMarketingEmails?: InputMaybe<Scalars['Boolean']['input']>;
    readonly canViewReports?: InputMaybe<Scalars['Boolean']['input']>;
    readonly stats?: InputMaybe<UserStats_Without_UserSettings_CreateInput>;
};

export type UserSettings_Without_User_ConnectionInput = {
    readonly create?: InputMaybe<UserSettings_Without_User_CreateInput>;
    readonly connectOrCreate?: InputMaybe<UserSettings_Without_User_CreateOrConnectInput>;
    readonly connect?: InputMaybe<UserSettings_WhereUnfilteredUniqueInput>;
};

export type UserStats = {
    readonly id: Scalars['String']['output'];
    readonly createdAt: Scalars['DateTime']['output'];
    readonly updatedAt: Scalars['DateTime']['output'];
    readonly likes: Scalars['Int']['output'];
    readonly dislikes: Scalars['Int']['output'];
    readonly views: Scalars['Int']['output'];
    readonly settings: UserSettings;
};

export type UserStats_QueryOutput = {
    readonly total: Scalars['Int']['output'];
    readonly items: ReadonlyArray<UserStats>;
};

export type UserStats_WhereInput = {
    readonly AND?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly id?: InputMaybe<StringFilterInput>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly likes?: InputMaybe<IntFilterInput>;
    readonly dislikes?: InputMaybe<IntFilterInput>;
    readonly views?: InputMaybe<IntFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type UserStats_OrderByInput = {
    readonly id?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly createdAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly updatedAt?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly likes?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly dislikes?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly views?: InputMaybe<SortOrder | `${SortOrder}`>;
    readonly settings?: InputMaybe<UserSettings_OrderByInput>;
};

export type UserStats_WhereUnfilteredUniqueInput = {
    readonly AND?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly OR?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly NOT?: InputMaybe<ReadonlyArray<UserStats_WhereInput>>;
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly likes?: InputMaybe<IntFilterInput>;
    readonly dislikes?: InputMaybe<IntFilterInput>;
    readonly views?: InputMaybe<IntFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type IntFilterInput = {
    readonly equals?: InputMaybe<Scalars['Int']['input']>;
    readonly in?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
    readonly notIn?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
    readonly lt?: InputMaybe<Scalars['Int']['input']>;
    readonly lte?: InputMaybe<Scalars['Int']['input']>;
    readonly gt?: InputMaybe<Scalars['Int']['input']>;
    readonly gte?: InputMaybe<Scalars['Int']['input']>;
    readonly not?: InputMaybe<IntFilterInput>;
};

export type UserStats_CreateInput = {
    readonly data: ReadonlyArray<UserStats_CreateDataInput>;
};

export type UserStats_UpdateInput = {
    readonly data: UserStats_UpdateDataInput;
    readonly where: UserStats_WhereUnfilteredUniqueInput;
};

export type UserStats_UpsertInput = {
    readonly data: UserStats_UpdateDataInput;
    readonly where: UserStats_WhereRequiredProvidedUniqueInput;
};

export type UserStats_WhereRequiredProvidedUniqueInput = {
    readonly id: Scalars['String']['input'];
    readonly createdAt?: InputMaybe<DateTimeFilterInput>;
    readonly updatedAt?: InputMaybe<DateTimeFilterInput>;
    readonly likes?: InputMaybe<IntFilterInput>;
    readonly dislikes?: InputMaybe<IntFilterInput>;
    readonly views?: InputMaybe<IntFilterInput>;
    readonly settings?: InputMaybe<UserSettings_WhereInput>;
};

export type UserStats_CreateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly likes: Scalars['Int']['input'];
    readonly dislikes: Scalars['Int']['input'];
    readonly views: Scalars['Int']['input'];
    readonly settings: UserSettings_Without_UserStats_ConnectionInput;
};

export type UserStats_UpdateDataInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly likes?: InputMaybe<Scalars['Int']['input']>;
    readonly dislikes?: InputMaybe<Scalars['Int']['input']>;
    readonly views?: InputMaybe<Scalars['Int']['input']>;
    readonly settings?: InputMaybe<UserSettings_Without_UserStats_ConnectionInput>;
};

export type UserStats_Without_UserSettings_CreateOrConnectInput = {
    readonly connect: UserStats_WhereUnfilteredUniqueInput;
    readonly create: UserStats_Without_UserSettings_CreateInput;
};

export type UserStats_Without_UserSettings_CreateInput = {
    readonly id?: InputMaybe<Scalars['String']['input']>;
    readonly createdAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
    readonly likes: Scalars['Int']['input'];
    readonly dislikes: Scalars['Int']['input'];
    readonly views: Scalars['Int']['input'];
};

export type UserStats_Without_UserSettings_ConnectionInput = {
    readonly create?: InputMaybe<UserStats_Without_UserSettings_CreateInput>;
    readonly connectOrCreate?: InputMaybe<UserStats_Without_UserSettings_CreateOrConnectInput>;
    readonly connect?: InputMaybe<UserStats_WhereUnfilteredUniqueInput>;
};

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
    TResult,
    TKey extends string,
    TParent,
    TContext,
    TArgs,
> {
    subscribe: SubscriptionSubscribeFn<{[key in TKey]: TResult}, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {[key in TKey]: TResult}, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
    | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
    TResult,
    TKey extends string,
    TParent = {},
    TContext = {},
    TArgs = {},
> =
    | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
    | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
    obj: T,
    context: TContext,
    info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Mutation: ResolverTypeWrapper<{}>;
    Query: ResolverTypeWrapper<{}>;
    Int: ResolverTypeWrapper<Scalars['Int']['output']>;
    DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
    SortOrder: SortOrder;
    NullsOrder: NullsOrder;
    User_DistinctInput: User_DistinctInput;
    UserSettings_DistinctInput: UserSettings_DistinctInput;
    UserStats_DistinctInput: UserStats_DistinctInput;
    _AllModels: ResolverTypeWrapper<_AllModels>;
    User: ResolverTypeWrapper<User>;
    String: ResolverTypeWrapper<Scalars['String']['output']>;
    SortOrderWithNulls: SortOrderWithNulls;
    User_QueryOutput: ResolverTypeWrapper<User_QueryOutput>;
    User_WhereInput: User_WhereInput;
    User_OrderByInput: User_OrderByInput;
    User_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;
    StringFilterInput: StringFilterInput;
    DateTimeFilterInput: DateTimeFilterInput;
    User_CreateInput: User_CreateInput;
    User_UpdateInput: User_UpdateInput;
    User_UpsertInput: User_UpsertInput;
    User_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;
    User_CreateDataInput: User_CreateDataInput;
    User_UpdateDataInput: User_UpdateDataInput;
    User_Without_UserSettings_CreateOrConnectInput: User_Without_UserSettings_CreateOrConnectInput;
    User_Without_UserSettings_CreateInput: User_Without_UserSettings_CreateInput;
    User_Without_UserSettings_ConnectionInput: User_Without_UserSettings_ConnectionInput;
    UserSettings: ResolverTypeWrapper<UserSettings>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
    UserSettings_QueryOutput: ResolverTypeWrapper<UserSettings_QueryOutput>;
    UserSettings_WhereInput: UserSettings_WhereInput;
    UserSettings_OrderByInput: UserSettings_OrderByInput;
    UserSettings_WhereUnfilteredUniqueInput: UserSettings_WhereUnfilteredUniqueInput;
    BooleanFilterInput: BooleanFilterInput;
    UserSettings_CreateInput: UserSettings_CreateInput;
    UserSettings_UpdateInput: UserSettings_UpdateInput;
    UserSettings_UpsertInput: UserSettings_UpsertInput;
    UserSettings_WhereRequiredProvidedUniqueInput: UserSettings_WhereRequiredProvidedUniqueInput;
    UserSettings_CreateDataInput: UserSettings_CreateDataInput;
    UserSettings_UpdateDataInput: UserSettings_UpdateDataInput;
    UserSettings_Without_UserStats_CreateOrConnectInput: UserSettings_Without_UserStats_CreateOrConnectInput;
    UserSettings_Without_UserStats_CreateInput: UserSettings_Without_UserStats_CreateInput;
    UserSettings_Without_UserStats_ConnectionInput: UserSettings_Without_UserStats_ConnectionInput;
    UserSettings_Without_User_CreateOrConnectInput: UserSettings_Without_User_CreateOrConnectInput;
    UserSettings_Without_User_CreateInput: UserSettings_Without_User_CreateInput;
    UserSettings_Without_User_ConnectionInput: UserSettings_Without_User_ConnectionInput;
    UserStats: ResolverTypeWrapper<UserStats>;
    UserStats_QueryOutput: ResolverTypeWrapper<UserStats_QueryOutput>;
    UserStats_WhereInput: UserStats_WhereInput;
    UserStats_OrderByInput: UserStats_OrderByInput;
    UserStats_WhereUnfilteredUniqueInput: UserStats_WhereUnfilteredUniqueInput;
    IntFilterInput: IntFilterInput;
    UserStats_CreateInput: UserStats_CreateInput;
    UserStats_UpdateInput: UserStats_UpdateInput;
    UserStats_UpsertInput: UserStats_UpsertInput;
    UserStats_WhereRequiredProvidedUniqueInput: UserStats_WhereRequiredProvidedUniqueInput;
    UserStats_CreateDataInput: UserStats_CreateDataInput;
    UserStats_UpdateDataInput: UserStats_UpdateDataInput;
    UserStats_Without_UserSettings_CreateOrConnectInput: UserStats_Without_UserSettings_CreateOrConnectInput;
    UserStats_Without_UserSettings_CreateInput: UserStats_Without_UserSettings_CreateInput;
    UserStats_Without_UserSettings_ConnectionInput: UserStats_Without_UserSettings_ConnectionInput;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
    Mutation: {};
    Query: {};
    Int: Scalars['Int']['output'];
    DateTime: Scalars['DateTime']['output'];
    _AllModels: _AllModels;
    User: User;
    String: Scalars['String']['output'];
    SortOrderWithNulls: SortOrderWithNulls;
    User_QueryOutput: User_QueryOutput;
    User_WhereInput: User_WhereInput;
    User_OrderByInput: User_OrderByInput;
    User_WhereUnfilteredUniqueInput: User_WhereUnfilteredUniqueInput;
    StringFilterInput: StringFilterInput;
    DateTimeFilterInput: DateTimeFilterInput;
    User_CreateInput: User_CreateInput;
    User_UpdateInput: User_UpdateInput;
    User_UpsertInput: User_UpsertInput;
    User_WhereRequiredProvidedUniqueInput: User_WhereRequiredProvidedUniqueInput;
    User_CreateDataInput: User_CreateDataInput;
    User_UpdateDataInput: User_UpdateDataInput;
    User_Without_UserSettings_CreateOrConnectInput: User_Without_UserSettings_CreateOrConnectInput;
    User_Without_UserSettings_CreateInput: User_Without_UserSettings_CreateInput;
    User_Without_UserSettings_ConnectionInput: User_Without_UserSettings_ConnectionInput;
    UserSettings: UserSettings;
    Boolean: Scalars['Boolean']['output'];
    UserSettings_QueryOutput: UserSettings_QueryOutput;
    UserSettings_WhereInput: UserSettings_WhereInput;
    UserSettings_OrderByInput: UserSettings_OrderByInput;
    UserSettings_WhereUnfilteredUniqueInput: UserSettings_WhereUnfilteredUniqueInput;
    BooleanFilterInput: BooleanFilterInput;
    UserSettings_CreateInput: UserSettings_CreateInput;
    UserSettings_UpdateInput: UserSettings_UpdateInput;
    UserSettings_UpsertInput: UserSettings_UpsertInput;
    UserSettings_WhereRequiredProvidedUniqueInput: UserSettings_WhereRequiredProvidedUniqueInput;
    UserSettings_CreateDataInput: UserSettings_CreateDataInput;
    UserSettings_UpdateDataInput: UserSettings_UpdateDataInput;
    UserSettings_Without_UserStats_CreateOrConnectInput: UserSettings_Without_UserStats_CreateOrConnectInput;
    UserSettings_Without_UserStats_CreateInput: UserSettings_Without_UserStats_CreateInput;
    UserSettings_Without_UserStats_ConnectionInput: UserSettings_Without_UserStats_ConnectionInput;
    UserSettings_Without_User_CreateOrConnectInput: UserSettings_Without_User_CreateOrConnectInput;
    UserSettings_Without_User_CreateInput: UserSettings_Without_User_CreateInput;
    UserSettings_Without_User_ConnectionInput: UserSettings_Without_User_ConnectionInput;
    UserStats: UserStats;
    UserStats_QueryOutput: UserStats_QueryOutput;
    UserStats_WhereInput: UserStats_WhereInput;
    UserStats_OrderByInput: UserStats_OrderByInput;
    UserStats_WhereUnfilteredUniqueInput: UserStats_WhereUnfilteredUniqueInput;
    IntFilterInput: IntFilterInput;
    UserStats_CreateInput: UserStats_CreateInput;
    UserStats_UpdateInput: UserStats_UpdateInput;
    UserStats_UpsertInput: UserStats_UpsertInput;
    UserStats_WhereRequiredProvidedUniqueInput: UserStats_WhereRequiredProvidedUniqueInput;
    UserStats_CreateDataInput: UserStats_CreateDataInput;
    UserStats_UpdateDataInput: UserStats_UpdateDataInput;
    UserStats_Without_UserSettings_CreateOrConnectInput: UserStats_Without_UserSettings_CreateOrConnectInput;
    UserStats_Without_UserSettings_CreateInput: UserStats_Without_UserSettings_CreateInput;
    UserStats_Without_UserSettings_ConnectionInput: UserStats_Without_UserSettings_ConnectionInput;
};

export type MutationResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation'],
> = {
    Users?: Resolver<
        ResolversTypes['User_QueryOutput'],
        ParentType,
        ContextType,
        Partial<Mutation_UsersArgs>
    >;
    UserSettings?: Resolver<
        ResolversTypes['UserSettings_QueryOutput'],
        ParentType,
        ContextType,
        Partial<Mutation_UserSettingsArgs>
    >;
    UserStats?: Resolver<
        ResolversTypes['UserStats_QueryOutput'],
        ParentType,
        ContextType,
        Partial<Mutation_UserStatsArgs>
    >;
};

export type QueryResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query'],
> = {
    Users?: Resolver<
        ResolversTypes['User_QueryOutput'],
        ParentType,
        ContextType,
        RequireFields<Query_UsersArgs, 'where'>
    >;
    UserSettings?: Resolver<
        ResolversTypes['UserSettings_QueryOutput'],
        ParentType,
        ContextType,
        RequireFields<Query_UserSettingsArgs, 'where'>
    >;
    UserStats?: Resolver<
        ResolversTypes['UserStats_QueryOutput'],
        ParentType,
        ContextType,
        RequireFields<Query_UserStatsArgs, 'where'>
    >;
};

export interface DateTimeScalarConfig
    extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type _AllModelsResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['_AllModels'] = ResolversParentTypes['_AllModels'],
> = {
    User?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
    UserSettings?: Resolver<Maybe<ResolversTypes['UserSettings']>, ParentType, ContextType>;
    UserStats?: Resolver<Maybe<ResolversTypes['UserStats']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User'],
> = {
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    password?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    phoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<ResolversTypes['UserSettings']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type User_QueryOutputResolvers<
    ContextType = any,
    ParentType extends
        ResolversParentTypes['User_QueryOutput'] = ResolversParentTypes['User_QueryOutput'],
> = {
    total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    items?: Resolver<ReadonlyArray<ResolversTypes['User']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettingsResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['UserSettings'] = ResolversParentTypes['UserSettings'],
> = {
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    receivesMarketingEmails?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    canViewReports?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    stats?: Resolver<Maybe<ResolversTypes['UserStats']>, ParentType, ContextType>;
    user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserSettings_QueryOutputResolvers<
    ContextType = any,
    ParentType extends
        ResolversParentTypes['UserSettings_QueryOutput'] = ResolversParentTypes['UserSettings_QueryOutput'],
> = {
    total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    items?: Resolver<ReadonlyArray<ResolversTypes['UserSettings']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStatsResolvers<
    ContextType = any,
    ParentType extends ResolversParentTypes['UserStats'] = ResolversParentTypes['UserStats'],
> = {
    id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
    likes?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    dislikes?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    views?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    settings?: Resolver<ResolversTypes['UserSettings'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserStats_QueryOutputResolvers<
    ContextType = any,
    ParentType extends
        ResolversParentTypes['UserStats_QueryOutput'] = ResolversParentTypes['UserStats_QueryOutput'],
> = {
    total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    items?: Resolver<ReadonlyArray<ResolversTypes['UserStats']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
    Mutation?: MutationResolvers<ContextType>;
    Query?: QueryResolvers<ContextType>;
    DateTime?: GraphQLScalarType;
    _AllModels?: _AllModelsResolvers<ContextType>;
    User?: UserResolvers<ContextType>;
    User_QueryOutput?: User_QueryOutputResolvers<ContextType>;
    UserSettings?: UserSettingsResolvers<ContextType>;
    UserSettings_QueryOutput?: UserSettings_QueryOutputResolvers<ContextType>;
    UserStats?: UserStatsResolvers<ContextType>;
    UserStats_QueryOutput?: UserStats_QueryOutputResolvers<ContextType>;
};

import type {SchemaOperationParams} from '@prisma-to-graphql/graphql-codegen-operation-params';

export const operationParams: Readonly<SchemaOperationParams> = {
    Mutation: {
        Users: {
            args: {
                create: 'User_CreateInput',
                update: 'User_UpdateInput',
                upsert: 'User_UpsertInput',
            },
            output: 'User_QueryOutput!',
        },
        UserSettings: {
            args: {
                create: 'UserSettings_CreateInput',
                update: 'UserSettings_UpdateInput',
                upsert: 'UserSettings_UpsertInput',
            },
            output: 'UserSettings_QueryOutput!',
        },
        UserStats: {
            args: {
                create: 'UserStats_CreateInput',
                update: 'UserStats_UpdateInput',
                upsert: 'UserStats_UpsertInput',
            },
            output: 'UserStats_QueryOutput!',
        },
    },
    Query: {
        Users: {
            args: {
                where: 'User_WhereInput!',
                orderBy: '[User_OrderByInput!]',
                cursor: 'User_WhereUnfilteredUniqueInput',
                distinct: '[User_DistinctInput!]',
                take: 'Int',
                skip: 'Int',
            },
            output: 'User_QueryOutput!',
        },
        UserSettings: {
            args: {
                where: 'UserSettings_WhereInput!',
                orderBy: '[UserSettings_OrderByInput!]',
                cursor: 'UserSettings_WhereUnfilteredUniqueInput',
                distinct: '[UserSettings_DistinctInput!]',
                take: 'Int',
                skip: 'Int',
            },
            output: 'UserSettings_QueryOutput!',
        },
        UserStats: {
            args: {
                where: 'UserStats_WhereInput!',
                orderBy: '[UserStats_OrderByInput!]',
                cursor: 'UserStats_WhereUnfilteredUniqueInput',
                distinct: '[UserStats_DistinctInput!]',
                take: 'Int',
                skip: 'Int',
            },
            output: 'UserStats_QueryOutput!',
        },
    },
};
